"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/demo/page",{

/***/ "(app-pages-browser)/./app/state/analysisStore.ts":
/*!************************************!*\
  !*** ./app/state/analysisStore.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAnalysisStore: function() { return /* binding */ useAnalysisStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _services_analysis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/analysis */ \"(app-pages-browser)/./app/services/analysis.ts\");\n\n\n\nconst useAnalysisStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.devtools)((set, get)=>({\n        // Initial state\n        currentAnalysis: null,\n        currentAnalysisId: null,\n        analysisHistory: [],\n        isLoading: false,\n        error: null,\n        currentPhase: \"idle\",\n        progress: 0,\n        rawBiomarkers: {},\n        normalizedBiomarkers: {},\n        unmappedBiomarkers: [],\n        userProfile: null,\n        questionnaireResponses: {},\n        questionnaireCompleted: false,\n        eventSource: null,\n        // Basic setters\n        setCurrentAnalysis: (analysis)=>set({\n                currentAnalysis: analysis\n            }),\n        setCurrentAnalysisId: (analysisId)=>set({\n                currentAnalysisId: analysisId\n            }),\n        addToHistory: (analysis)=>set((state)=>({\n                    analysisHistory: [\n                        analysis,\n                        ...state.analysisHistory.slice(0, 49)\n                    ] // Keep last 50\n                })),\n        setLoading: (loading)=>set({\n                isLoading: loading\n            }),\n        setError: (error)=>set({\n                error\n            }),\n        setPhase: (phase)=>set({\n                currentPhase: phase\n            }),\n        setProgress: (progress)=>set({\n                progress: Math.max(0, Math.min(100, progress))\n            }),\n        setRawBiomarkers: (biomarkers)=>set({\n                rawBiomarkers: biomarkers\n            }),\n        setNormalizedBiomarkers: (biomarkers)=>set({\n                normalizedBiomarkers: biomarkers\n            }),\n        setUnmappedBiomarkers: (unmapped)=>set({\n                unmappedBiomarkers: unmapped\n            }),\n        setUserProfile: (profile)=>set({\n                userProfile: profile\n            }),\n        setQuestionnaireResponses: (responses)=>set({\n                questionnaireResponses: responses\n            }),\n        setQuestionnaireCompleted: (completed)=>set({\n                questionnaireCompleted: completed\n            }),\n        // Questionnaire actions\n        setResponse: (id, value)=>set((state)=>({\n                    questionnaireResponses: {\n                        ...state.questionnaireResponses,\n                        [id]: value\n                    }\n                })),\n        getResponse: (id)=>{\n            const state = get();\n            return state.questionnaireResponses[id];\n        },\n        resetResponses: ()=>set({\n                questionnaireResponses: {}\n            }),\n        // Complex actions\n        startAnalysis: async (request)=>{\n            // Validate input data\n            const biomarkerValidation = _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.validateBiomarkerData(request.biomarkers);\n            const userValidation = _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.validateUserProfile(request.user);\n            if (!biomarkerValidation.valid || !userValidation.valid) {\n                const errors = [\n                    ...biomarkerValidation.errors,\n                    ...userValidation.errors\n                ];\n                set({\n                    error: {\n                        message: \"Validation failed: \".concat(errors.join(\", \")),\n                        code: \"VALIDATION_ERROR\",\n                        details: {\n                            biomarkerErrors: biomarkerValidation.errors,\n                            userErrors: userValidation.errors\n                        }\n                    },\n                    isLoading: false,\n                    currentPhase: \"idle\"\n                });\n                return;\n            }\n            set({\n                isLoading: true,\n                error: null,\n                currentPhase: \"ingestion\",\n                progress: 0,\n                rawBiomarkers: request.biomarkers,\n                userProfile: request.user,\n                questionnaireResponses: request.questionnaire || {}\n            });\n            try {\n                // Call the API service\n                const response = await _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.startAnalysis(request);\n                if (!response.success) {\n                    throw new Error(response.error || \"Failed to start analysis\");\n                }\n                const analysisId = response.data.analysis_id;\n                const analysis = {\n                    analysis_id: analysisId,\n                    status: \"pending\",\n                    progress: 0,\n                    created_at: new Date().toISOString()\n                };\n                set({\n                    currentAnalysis: analysis,\n                    currentAnalysisId: analysisId,\n                    isLoading: false,\n                    error: null,\n                    currentPhase: \"ingestion\",\n                    progress: 0\n                });\n                // Add to history\n                get().addToHistory(analysis);\n                // Start listening to SSE events\n                const eventSource = _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.subscribeToAnalysisEvents(analysisId, (event)=>{\n                    try {\n                        const data = JSON.parse(event.data);\n                        console.log(\"SSE Event received:\", data);\n                        // Handle analysis_status events\n                        if (data.phase && typeof data.progress === \"number\") {\n                            get().updateAnalysisProgress(analysisId, data.progress, data.phase);\n                            // Check if this is a completion event\n                            if (data.phase === \"complete\") {\n                                get().completeAnalysis(analysisId, data.results);\n                            }\n                        } else if (data.type === \"complete\" || data.phase === \"complete\") {\n                            get().completeAnalysis(analysisId, data.results);\n                        } else if (data.type === \"error\" || data.error) {\n                            get().failAnalysis(analysisId, {\n                                message: data.message || data.error || \"Analysis failed\",\n                                code: data.code || \"ANALYSIS_ERROR\",\n                                details: data.details\n                            });\n                        }\n                    } catch (error) {\n                        console.error(\"Failed to parse SSE event:\", error);\n                    }\n                }, (error)=>{\n                    console.error(\"SSE connection error:\", error);\n                    // Only fail if analysis hasn't completed\n                    const state = get();\n                    if (state.currentPhase !== \"completed\") {\n                        get().failAnalysis(analysisId, {\n                            message: \"Connection lost during analysis\",\n                            code: \"CONNECTION_ERROR\",\n                            details: error\n                        });\n                    } else {\n                        console.log(\"SSE error after completion - ignoring\");\n                    }\n                }, ()=>{\n                    console.log(\"Analysis completed via SSE\");\n                    get().completeAnalysis(analysisId, null);\n                });\n                // Store event source for cleanup\n                set({\n                    eventSource\n                });\n            } catch (error) {\n                set({\n                    error: {\n                        message: error instanceof Error ? error.message : \"Failed to start analysis\",\n                        code: \"API_ERROR\",\n                        details: error\n                    },\n                    isLoading: false,\n                    currentPhase: \"idle\"\n                });\n            }\n        },\n        updateAnalysisProgress: (analysisId, progress, phase)=>{\n            var _state_currentAnalysis;\n            const state = get();\n            if (((_state_currentAnalysis = state.currentAnalysis) === null || _state_currentAnalysis === void 0 ? void 0 : _state_currentAnalysis.analysis_id) === analysisId) {\n                set({\n                    currentAnalysis: {\n                        ...state.currentAnalysis,\n                        status: \"processing\",\n                        progress\n                    },\n                    progress,\n                    currentPhase: phase\n                });\n            }\n        },\n        completeAnalysis: async (analysisId, results)=>{\n            var _state_currentAnalysis;\n            const state = get();\n            if (((_state_currentAnalysis = state.currentAnalysis) === null || _state_currentAnalysis === void 0 ? void 0 : _state_currentAnalysis.analysis_id) === analysisId) {\n                try {\n                    // Fetch the full analysis results from the API\n                    const response = await _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.getAnalysisResult(analysisId);\n                    if (response && response.success && response.data) {\n                        const completedAnalysis = {\n                            ...state.currentAnalysis,\n                            ...response.data,\n                            completed_at: new Date().toISOString()\n                        };\n                        set({\n                            currentAnalysis: completedAnalysis,\n                            isLoading: false,\n                            currentPhase: \"completed\",\n                            progress: 100,\n                            error: null\n                        });\n                        // Update in history\n                        get().addToHistory(completedAnalysis);\n                    } else {\n                        // Fallback to the results passed in (if any)\n                        const completedAnalysis = {\n                            ...state.currentAnalysis,\n                            status: \"completed\",\n                            progress: 100,\n                            results: results || {\n                                biomarkers: [],\n                                clusters: [],\n                                insights: [],\n                                risk_assessment: {},\n                                recommendations: []\n                            },\n                            completed_at: new Date().toISOString()\n                        };\n                        set({\n                            currentAnalysis: completedAnalysis,\n                            isLoading: false,\n                            currentPhase: \"completed\",\n                            progress: 100,\n                            error: null\n                        });\n                        // Update in history\n                        get().addToHistory(completedAnalysis);\n                    }\n                } catch (error) {\n                    console.error(\"Failed to fetch analysis results:\", error);\n                    // Fallback to the results passed in (if any)\n                    const completedAnalysis = {\n                        ...state.currentAnalysis,\n                        status: \"completed\",\n                        progress: 100,\n                        results: results || {\n                            biomarkers: [],\n                            clusters: [],\n                            insights: [],\n                            risk_assessment: {},\n                            recommendations: []\n                        },\n                        completed_at: new Date().toISOString()\n                    };\n                    set({\n                        currentAnalysis: completedAnalysis,\n                        isLoading: false,\n                        currentPhase: \"completed\",\n                        progress: 100,\n                        error: null\n                    });\n                    // Update in history\n                    get().addToHistory(completedAnalysis);\n                }\n            } else {\n                // If no current analysis, just update the phase and progress\n                set({\n                    isLoading: false,\n                    currentPhase: \"completed\",\n                    progress: 100,\n                    error: null\n                });\n            }\n        },\n        failAnalysis: (analysisId, error)=>{\n            var _state_currentAnalysis;\n            const state = get();\n            if (((_state_currentAnalysis = state.currentAnalysis) === null || _state_currentAnalysis === void 0 ? void 0 : _state_currentAnalysis.analysis_id) === analysisId) {\n                const failedAnalysis = {\n                    ...state.currentAnalysis,\n                    status: \"failed\",\n                    completed_at: new Date().toISOString()\n                };\n                set({\n                    currentAnalysis: failedAnalysis,\n                    isLoading: false,\n                    currentPhase: \"error\",\n                    error\n                });\n                // Update in history\n                get().addToHistory(failedAnalysis);\n            } else {\n                // If no current analysis, just update the phase and error\n                set({\n                    isLoading: false,\n                    currentPhase: \"error\",\n                    error\n                });\n            }\n        },\n        clearAnalysis: ()=>{\n            // Close any active SSE connection\n            const state = get();\n            if (state.eventSource) {\n                state.eventSource.close();\n            }\n            set({\n                currentAnalysis: null,\n                currentAnalysisId: null,\n                isLoading: false,\n                error: null,\n                currentPhase: \"idle\",\n                progress: 0,\n                rawBiomarkers: {},\n                normalizedBiomarkers: {},\n                unmappedBiomarkers: [],\n                questionnaireResponses: {},\n                questionnaireCompleted: false,\n                eventSource: null\n            });\n        },\n        retryAnalysis: ()=>{\n            const state = get();\n            if (state.currentAnalysis && state.userProfile) {\n                const request = {\n                    biomarkers: state.rawBiomarkers,\n                    user: state.userProfile,\n                    questionnaire: state.questionnaireResponses\n                };\n                get().startAnalysis(request);\n            }\n        },\n        // Utility functions\n        getAnalysisById: (analysisId)=>{\n            const state = get();\n            return state.analysisHistory.find((analysis)=>analysis.analysis_id === analysisId);\n        },\n        getRecentAnalyses: function() {\n            let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n            const state = get();\n            return state.analysisHistory.slice(0, limit);\n        },\n        isAnalysisComplete: ()=>{\n            var _state_currentAnalysis;\n            const state = get();\n            return ((_state_currentAnalysis = state.currentAnalysis) === null || _state_currentAnalysis === void 0 ? void 0 : _state_currentAnalysis.status) === \"completed\";\n        },\n        getAnalysisSummary: ()=>{\n            const state = get();\n            const analyses = state.analysisHistory;\n            const completed = analyses.filter((a)=>a.status === \"completed\");\n            const failed = analyses.filter((a)=>a.status === \"failed\");\n            const scores = completed.map((a)=>{\n                var _a_results;\n                return (_a_results = a.results) === null || _a_results === void 0 ? void 0 : _a_results.overall_score;\n            }).filter((score)=>typeof score === \"number\");\n            return {\n                totalAnalyses: analyses.length,\n                completedAnalyses: completed.length,\n                failedAnalyses: failed.length,\n                averageScore: scores.length > 0 ? scores.reduce((a, b)=>a + b, 0) / scores.length : 0\n            };\n        }\n    }), {\n    name: \"analysis-store\"\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zdGF0ZS9hbmFseXNpc1N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7QUFDYTtBQUNTO0FBNEdoRCxNQUFNRyxtQkFBbUJILCtDQUFNQSxHQUNwQ0MsNERBQVFBLENBQ04sQ0FBQ0csS0FBS0MsTUFBUztRQUNiLGdCQUFnQjtRQUNoQkMsaUJBQWlCO1FBQ2pCQyxtQkFBbUI7UUFDbkJDLGlCQUFpQixFQUFFO1FBQ25CQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsY0FBYztRQUNkQyxVQUFVO1FBQ1ZDLGVBQWUsQ0FBQztRQUNoQkMsc0JBQXNCLENBQUM7UUFDdkJDLG9CQUFvQixFQUFFO1FBQ3RCQyxhQUFhO1FBQ2JDLHdCQUF3QixDQUFDO1FBQ3pCQyx3QkFBd0I7UUFDeEJDLGFBQWE7UUFFYixnQkFBZ0I7UUFDaEJDLG9CQUFvQixDQUFDQyxXQUFhakIsSUFBSTtnQkFBRUUsaUJBQWlCZTtZQUFTO1FBRWxFQyxzQkFBc0IsQ0FBQ0MsYUFBZW5CLElBQUk7Z0JBQUVHLG1CQUFtQmdCO1lBQVc7UUFFMUVDLGNBQWMsQ0FBQ0gsV0FBYWpCLElBQUksQ0FBQ3FCLFFBQVc7b0JBQzFDakIsaUJBQWlCO3dCQUFDYTsyQkFBYUksTUFBTWpCLGVBQWUsQ0FBQ2tCLEtBQUssQ0FBQyxHQUFHO3FCQUFJLENBQUMsZUFBZTtnQkFDcEY7UUFFQUMsWUFBWSxDQUFDQyxVQUFZeEIsSUFBSTtnQkFBRUssV0FBV21CO1lBQVE7UUFFbERDLFVBQVUsQ0FBQ25CLFFBQVVOLElBQUk7Z0JBQUVNO1lBQU07UUFFakNvQixVQUFVLENBQUNDLFFBQVUzQixJQUFJO2dCQUFFTyxjQUFjb0I7WUFBTTtRQUUvQ0MsYUFBYSxDQUFDcEIsV0FBYVIsSUFBSTtnQkFBRVEsVUFBVXFCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBS3ZCO1lBQVc7UUFFaEZ3QixrQkFBa0IsQ0FBQ0MsYUFBZWpDLElBQUk7Z0JB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VUFBVW9FLE1BQU07Z0JBQ25DRSxnQkFBZ0JSLE9BQU9NLE1BQU07Z0JBQzdCRyxjQUFjUixPQUFPSyxNQUFNLEdBQUcsSUFBSUwsT0FBT1MsTUFBTSxDQUFDLENBQUNYLEdBQUdZLElBQU1aLElBQUlZLEdBQUcsS0FBS1YsT0FBT0ssTUFBTSxHQUFHO1lBQ3hGO1FBQ0Y7SUFDRixJQUNBO0lBQ0VNLE1BQU07QUFDUixJQUVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9zdGF0ZS9hbmFseXNpc1N0b3JlLnRzP2UwNzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBkZXZ0b29scyB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBBbmFseXNpc1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9hbmFseXNpcyc7XG5pbXBvcnQgeyBCaW9tYXJrZXJWYWx1ZSwgQmlvbWFya2VyRGF0YSwgVXNlclByb2ZpbGUsIEFuYWx5c2lzUmVxdWVzdCB9IGZyb20gJy4uL3R5cGVzL2FuYWx5c2lzJztcblxuZXhwb3J0IGludGVyZmFjZSBCaW9tYXJrZXJSZXN1bHQge1xuICBiaW9tYXJrZXJfbmFtZTogc3RyaW5nO1xuICB2YWx1ZTogbnVtYmVyO1xuICB1bml0OiBzdHJpbmc7XG4gIHNjb3JlOiBudW1iZXI7XG4gIHBlcmNlbnRpbGU/OiBudW1iZXI7XG4gIHN0YXR1czogJ29wdGltYWwnIHwgJ25vcm1hbCcgfCAnZWxldmF0ZWQnIHwgJ2xvdycgfCAnY3JpdGljYWwnO1xuICByZWZlcmVuY2VfcmFuZ2U/OiB7XG4gICAgbWluOiBudW1iZXI7XG4gICAgbWF4OiBudW1iZXI7XG4gICAgdW5pdDogc3RyaW5nO1xuICB9O1xuICBpbnRlcnByZXRhdGlvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5c2lzUmVzdWx0IHtcbiAgYW5hbHlzaXNfaWQ6IHN0cmluZztcbiAgc3RhdHVzOiAncGVuZGluZycgfCAncHJvY2Vzc2luZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnO1xuICBwcm9ncmVzcz86IG51bWJlcjtcbiAgcmVzdWx0cz86IHtcbiAgICBiaW9tYXJrZXJzOiBCaW9tYXJrZXJSZXN1bHRbXTtcbiAgICBjbHVzdGVyczogYW55W107XG4gICAgaW5zaWdodHM6IGFueVtdO1xuICAgIG92ZXJhbGxfc2NvcmU/OiBudW1iZXI7XG4gICAgcmlza19hc3Nlc3NtZW50OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIHJlY29tbWVuZGF0aW9uczogc3RyaW5nW107XG4gIH07XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgY29tcGxldGVkX2F0Pzogc3RyaW5nO1xuICBwcm9jZXNzaW5nX3RpbWVfc2Vjb25kcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbmFseXNpc0Vycm9yIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBjb2RlOiBzdHJpbmc7XG4gIGRldGFpbHM/OiBhbnk7XG59XG5cbmludGVyZmFjZSBBbmFseXNpc1N0YXRlIHtcbiAgLy8gQ3VycmVudCBhbmFseXNpcyBzdGF0ZVxuICBjdXJyZW50QW5hbHlzaXM6IEFuYWx5c2lzUmVzdWx0IHwgbnVsbDtcbiAgY3VycmVudEFuYWx5c2lzSWQ6IHN0cmluZyB8IG51bGw7XG4gIGFuYWx5c2lzSGlzdG9yeTogQW5hbHlzaXNSZXN1bHRbXTtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogQW5hbHlzaXNFcnJvciB8IG51bGw7XG4gIFxuICAvLyBBbmFseXNpcyB3b3JrZmxvdyBzdGF0ZVxuICBjdXJyZW50UGhhc2U6ICdpZGxlJyB8ICdpbmdlc3Rpb24nIHwgJ25vcm1hbGl6YXRpb24nIHwgJ3Njb3JpbmcnIHwgJ2NsdXN0ZXJpbmcnIHwgJ2luc2lnaHRzJyB8ICdjb21wbGV0ZWQnIHwgJ2Vycm9yJztcbiAgcHJvZ3Jlc3M6IG51bWJlcjtcbiAgXG4gIC8vIEJpb21hcmtlciBkYXRhIHN0YXRlXG4gIHJhd0Jpb21hcmtlcnM6IEJpb21hcmtlckRhdGE7XG4gIG5vcm1hbGl6ZWRCaW9tYXJrZXJzOiBCaW9tYXJrZXJEYXRhO1xuICB1bm1hcHBlZEJpb21hcmtlcnM6IHN0cmluZ1tdO1xuICBcbiAgLy8gVXNlciBjb250ZXh0XG4gIHVzZXJQcm9maWxlOiBVc2VyUHJvZmlsZSB8IG51bGw7XG4gIFxuICAvLyBRdWVzdGlvbm5haXJlIHN0YXRlXG4gIHF1ZXN0aW9ubmFpcmVSZXNwb25zZXM6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIHF1ZXN0aW9ubmFpcmVDb21wbGV0ZWQ6IGJvb2xlYW47XG4gIFxuICAvLyBTU0UgY29ubmVjdGlvblxuICBldmVudFNvdXJjZTogRXZlbnRTb3VyY2UgfCBudWxsO1xuICBcbiAgLy8gQWN0aW9uc1xuICBzZXRDdXJyZW50QW5hbHlzaXM6IChhbmFseXNpczogQW5hbHlzaXNSZXN1bHQgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRDdXJyZW50QW5hbHlzaXNJZDogKGFuYWx5c2lzSWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIGFkZFRvSGlzdG9yeTogKGFuYWx5c2lzOiBBbmFseXNpc1Jlc3VsdCkgPT4gdm9pZDtcbiAgc2V0TG9hZGluZzogKGxvYWRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHNldEVycm9yOiAoZXJyb3I6IEFuYWx5c2lzRXJyb3IgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRQaGFzZTogKHBoYXNlOiBBbmFseXNpc1N0YXRlWydjdXJyZW50UGhhc2UnXSkgPT4gdm9pZDtcbiAgc2V0UHJvZ3Jlc3M6IChwcm9ncmVzczogbnVtYmVyKSA9PiB2b2lkO1xuICBzZXRSYXdCaW9tYXJrZXJzOiAoYmlvbWFya2VyczogQmlvbWFya2VyRGF0YSkgPT4gdm9pZDtcbiAgc2V0Tm9ybWFsaXplZEJpb21hcmtlcnM6IChiaW9tYXJrZXJzOiBCaW9tYXJrZXJEYXRhKSA9PiB2b2lkO1xuICBzZXRVbm1hcHBlZEJpb21hcmtlcnM6ICh1bm1hcHBlZDogc3RyaW5nW10pID0+IHZvaWQ7XG4gIHNldFVzZXJQcm9maWxlOiAocHJvZmlsZTogVXNlclByb2ZpbGUgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRRdWVzdGlvbm5haXJlUmVzcG9uc2VzOiAocmVzcG9uc2VzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiB2b2lkO1xuICBzZXRRdWVzdGlvbm5haXJlQ29tcGxldGVkOiAoY29tcGxldGVkOiBib29sZWFuKSA9PiB2b2lkO1xuICBcbiAgLy8gQ29tcGxleCBhY3Rpb25zXG4gIHN0YXJ0QW5hbHlzaXM6IChyZXF1ZXN0OiBBbmFseXNpc1JlcXVlc3QpID0+IFByb21pc2U8dm9pZD47XG4gIHVwZGF0ZUFuYWx5c2lzUHJvZ3Jlc3M6IChhbmFseXNpc0lkOiBzdHJpbmcsIHByb2dyZXNzOiBudW1iZXIsIHBoYXNlOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNvbXBsZXRlQW5hbHlzaXM6IChhbmFseXNpc0lkOiBzdHJpbmcsIHJlc3VsdHM6IEFuYWx5c2lzUmVzdWx0WydyZXN1bHRzJ10pID0+IFByb21pc2U8dm9pZD47XG4gIGZhaWxBbmFseXNpczogKGFuYWx5c2lzSWQ6IHN0cmluZywgZXJyb3I6IEFuYWx5c2lzRXJyb3IpID0+IHZvaWQ7XG4gIGNsZWFyQW5hbHlzaXM6ICgpID0+IHZvaWQ7XG4gIHJldHJ5QW5hbHlzaXM6ICgpID0+IHZvaWQ7XG4gIFxuICAvLyBRdWVzdGlvbm5haXJlIGFjdGlvbnNcbiAgc2V0UmVzcG9uc2U6IChpZDogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB2b2lkO1xuICBnZXRSZXNwb25zZTogKGlkOiBzdHJpbmcpID0+IGFueTtcbiAgcmVzZXRSZXNwb25zZXM6ICgpID0+IHZvaWQ7XG4gIFxuICAvLyBVdGlsaXR5IGFjdGlvbnNcbiAgZ2V0QW5hbHlzaXNCeUlkOiAoYW5hbHlzaXNJZDogc3RyaW5nKSA9PiBBbmFseXNpc1Jlc3VsdCB8IHVuZGVmaW5lZDtcbiAgZ2V0UmVjZW50QW5hbHlzZXM6IChsaW1pdD86IG51bWJlcikgPT4gQW5hbHlzaXNSZXN1bHRbXTtcbiAgaXNBbmFseXNpc0NvbXBsZXRlOiAoKSA9PiBib29sZWFuO1xuICBnZXRBbmFseXNpc1N1bW1hcnk6ICgpID0+IHtcbiAgICB0b3RhbEFuYWx5c2VzOiBudW1iZXI7XG4gICAgY29tcGxldGVkQW5hbHlzZXM6IG51bWJlcjtcbiAgICBmYWlsZWRBbmFseXNlczogbnVtYmVyO1xuICAgIGF2ZXJhZ2VTY29yZTogbnVtYmVyO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgdXNlQW5hbHlzaXNTdG9yZSA9IGNyZWF0ZTxBbmFseXNpc1N0YXRlPigpKFxuICBkZXZ0b29scyhcbiAgICAoc2V0LCBnZXQpID0+ICh7XG4gICAgICAvLyBJbml0aWFsIHN0YXRlXG4gICAgICBjdXJyZW50QW5hbHlzaXM6IG51bGwsXG4gICAgICBjdXJyZW50QW5hbHlzaXNJZDogbnVsbCxcbiAgICAgIGFuYWx5c2lzSGlzdG9yeTogW10sXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBjdXJyZW50UGhhc2U6ICdpZGxlJyxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgcmF3QmlvbWFya2Vyczoge30sXG4gICAgICBub3JtYWxpemVkQmlvbWFya2Vyczoge30sXG4gICAgICB1bm1hcHBlZEJpb21hcmtlcnM6IFtdLFxuICAgICAgdXNlclByb2ZpbGU6IG51bGwsXG4gICAgICBxdWVzdGlvbm5haXJlUmVzcG9uc2VzOiB7fSxcbiAgICAgIHF1ZXN0aW9ubmFpcmVDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgZXZlbnRTb3VyY2U6IG51bGwsXG5cbiAgICAgIC8vIEJhc2ljIHNldHRlcnNcbiAgICAgIHNldEN1cnJlbnRBbmFseXNpczogKGFuYWx5c2lzKSA9PiBzZXQoeyBjdXJyZW50QW5hbHlzaXM6IGFuYWx5c2lzIH0pLFxuICAgICAgXG4gICAgICBzZXRDdXJyZW50QW5hbHlzaXNJZDogKGFuYWx5c2lzSWQpID0+IHNldCh7IGN1cnJlbnRBbmFseXNpc0lkOiBhbmFseXNpc0lkIH0pLFxuICAgICAgXG4gICAgICBhZGRUb0hpc3Rvcnk6IChhbmFseXNpcykgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgYW5hbHlzaXNIaXN0b3J5OiBbYW5hbHlzaXMsIC4uLnN0YXRlLmFuYWx5c2lzSGlzdG9yeS5zbGljZSgwLCA0OSldIC8vIEtlZXAgbGFzdCA1MFxuICAgICAgfSkpLFxuICAgICAgXG4gICAgICBzZXRMb2FkaW5nOiAobG9hZGluZykgPT4gc2V0KHsgaXNMb2FkaW5nOiBsb2FkaW5nIH0pLFxuICAgICAgXG4gICAgICBzZXRFcnJvcjogKGVycm9yKSA9PiBzZXQoeyBlcnJvciB9KSxcbiAgICAgIFxuICAgICAgc2V0UGhhc2U6IChwaGFzZSkgPT4gc2V0KHsgY3VycmVudFBoYXNlOiBwaGFzZSB9KSxcbiAgICAgIFxuICAgICAgc2V0UHJvZ3Jlc3M6IChwcm9ncmVzcykgPT4gc2V0KHsgcHJvZ3Jlc3M6IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgcHJvZ3Jlc3MpKSB9KSxcbiAgICAgIFxuICAgICAgc2V0UmF3QmlvbWFya2VyczogKGJpb21hcmtlcnMpID0+IHNldCh7IHJhd0Jpb21hcmtlcnM6IGJpb21hcmtlcnMgfSksXG4gICAgICBcbiAgICAgIHNldE5vcm1hbGl6ZWRCaW9tYXJrZXJzOiAoYmlvbWFya2VycykgPT4gc2V0KHsgbm9ybWFsaXplZEJpb21hcmtlcnM6IGJpb21hcmtlcnMgfSksXG4gICAgICBcbiAgICAgIHNldFVubWFwcGVkQmlvbWFya2VyczogKHVubWFwcGVkKSA9PiBzZXQoeyB1bm1hcHBlZEJpb21hcmtlcnM6IHVubWFwcGVkIH0pLFxuICAgICAgXG4gICAgICBzZXRVc2VyUHJvZmlsZTogKHByb2ZpbGUpID0+IHNldCh7IHVzZXJQcm9maWxlOiBwcm9maWxlIH0pLFxuICAgICAgXG4gICAgICBzZXRRdWVzdGlvbm5haXJlUmVzcG9uc2VzOiAocmVzcG9uc2VzKSA9PiBzZXQoeyBxdWVzdGlvbm5haXJlUmVzcG9uc2VzOiByZXNwb25zZXMgfSksXG4gICAgICBcbiAgICAgIHNldFF1ZXN0aW9ubmFpcmVDb21wbGV0ZWQ6IChjb21wbGV0ZWQpID0+IHNldCh7IHF1ZXN0aW9ubmFpcmVDb21wbGV0ZWQ6IGNvbXBsZXRlZCB9KSxcblxuICAgICAgLy8gUXVlc3Rpb25uYWlyZSBhY3Rpb25zXG4gICAgICBzZXRSZXNwb25zZTogKGlkLCB2YWx1ZSkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgcXVlc3Rpb25uYWlyZVJlc3BvbnNlczogeyAuLi5zdGF0ZS5xdWVzdGlvbm5haXJlUmVzcG9uc2VzLCBbaWRdOiB2YWx1ZSB9XG4gICAgICB9KSksXG4gICAgICBcbiAgICAgIGdldFJlc3BvbnNlOiAoaWQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnF1ZXN0aW9ubmFpcmVSZXNwb25zZXNbaWRdO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgcmVzZXRSZXNwb25zZXM6ICgpID0+IHNldCh7IHF1ZXN0aW9ubmFpcmVSZXNwb25zZXM6IHt9IH0pLFxuXG4gICAgICAvLyBDb21wbGV4IGFjdGlvbnNcbiAgICAgIHN0YXJ0QW5hbHlzaXM6IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGlucHV0IGRhdGFcbiAgICAgICAgY29uc3QgYmlvbWFya2VyVmFsaWRhdGlvbiA9IEFuYWx5c2lzU2VydmljZS52YWxpZGF0ZUJpb21hcmtlckRhdGEocmVxdWVzdC5iaW9tYXJrZXJzKTtcbiAgICAgICAgY29uc3QgdXNlclZhbGlkYXRpb24gPSBBbmFseXNpc1NlcnZpY2UudmFsaWRhdGVVc2VyUHJvZmlsZShyZXF1ZXN0LnVzZXIpO1xuXG4gICAgICAgIGlmICghYmlvbWFya2VyVmFsaWRhdGlvbi52YWxpZCB8fCAhdXNlclZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbLi4uYmlvbWFya2VyVmFsaWRhdGlvbi5lcnJvcnMsIC4uLnVzZXJWYWxpZGF0aW9uLmVycm9yc107XG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBWYWxpZGF0aW9uIGZhaWxlZDogJHtlcnJvcnMuam9pbignLCAnKX1gLFxuICAgICAgICAgICAgICBjb2RlOiAnVkFMSURBVElPTl9FUlJPUicsXG4gICAgICAgICAgICAgIGRldGFpbHM6IHsgYmlvbWFya2VyRXJyb3JzOiBiaW9tYXJrZXJWYWxpZGF0aW9uLmVycm9ycywgdXNlckVycm9yczogdXNlclZhbGlkYXRpb24uZXJyb3JzIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnJlbnRQaGFzZTogJ2lkbGUnLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldCh7XG4gICAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIGN1cnJlbnRQaGFzZTogJ2luZ2VzdGlvbicsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgcmF3QmlvbWFya2VyczogcmVxdWVzdC5iaW9tYXJrZXJzLFxuICAgICAgICAgIHVzZXJQcm9maWxlOiByZXF1ZXN0LnVzZXIsXG4gICAgICAgICAgcXVlc3Rpb25uYWlyZVJlc3BvbnNlczogcmVxdWVzdC5xdWVzdGlvbm5haXJlIHx8IHt9LFxuICAgICAgICB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENhbGwgdGhlIEFQSSBzZXJ2aWNlXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBBbmFseXNpc1NlcnZpY2Uuc3RhcnRBbmFseXNpcyhyZXF1ZXN0KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvciB8fCAnRmFpbGVkIHRvIHN0YXJ0IGFuYWx5c2lzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYW5hbHlzaXNJZCA9IHJlc3BvbnNlLmRhdGEuYW5hbHlzaXNfaWQ7XG4gICAgICAgICAgY29uc3QgYW5hbHlzaXM6IEFuYWx5c2lzUmVzdWx0ID0ge1xuICAgICAgICAgICAgYW5hbHlzaXNfaWQ6IGFuYWx5c2lzSWQsXG4gICAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgY3VycmVudEFuYWx5c2lzOiBhbmFseXNpcyxcbiAgICAgICAgICAgIGN1cnJlbnRBbmFseXNpc0lkOiBhbmFseXNpc0lkLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSwgLy8gU2V0IHRvIGZhbHNlIGFmdGVyIHN1Y2Nlc3NmdWwgc3RhcnRcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgY3VycmVudFBoYXNlOiAnaW5nZXN0aW9uJywgLy8gTW92ZSB0byBpbmdlc3Rpb24gcGhhc2VcbiAgICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQWRkIHRvIGhpc3RvcnlcbiAgICAgICAgICBnZXQoKS5hZGRUb0hpc3RvcnkoYW5hbHlzaXMpO1xuXG4gICAgICAgICAgLy8gU3RhcnQgbGlzdGVuaW5nIHRvIFNTRSBldmVudHNcbiAgICAgICAgICBjb25zdCBldmVudFNvdXJjZSA9IEFuYWx5c2lzU2VydmljZS5zdWJzY3JpYmVUb0FuYWx5c2lzRXZlbnRzKFxuICAgICAgICAgICAgYW5hbHlzaXNJZCxcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTU0UgRXZlbnQgcmVjZWl2ZWQ6JywgZGF0YSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFuYWx5c2lzX3N0YXR1cyBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5waGFzZSAmJiB0eXBlb2YgZGF0YS5wcm9ncmVzcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIGdldCgpLnVwZGF0ZUFuYWx5c2lzUHJvZ3Jlc3MoYW5hbHlzaXNJZCwgZGF0YS5wcm9ncmVzcywgZGF0YS5waGFzZSk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjb21wbGV0aW9uIGV2ZW50XG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YS5waGFzZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICBnZXQoKS5jb21wbGV0ZUFuYWx5c2lzKGFuYWx5c2lzSWQsIGRhdGEucmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdjb21wbGV0ZScgfHwgZGF0YS5waGFzZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgICAgZ2V0KCkuY29tcGxldGVBbmFseXNpcyhhbmFseXNpc0lkLCBkYXRhLnJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnZXJyb3InIHx8IGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGdldCgpLmZhaWxBbmFseXNpcyhhbmFseXNpc0lkLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRhdGEubWVzc2FnZSB8fCBkYXRhLmVycm9yIHx8ICdBbmFseXNpcyBmYWlsZWQnLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBkYXRhLmNvZGUgfHwgJ0FOQUxZU0lTX0VSUk9SJyxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZGF0YS5kZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBTU0UgZXZlbnQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NTRSBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgLy8gT25seSBmYWlsIGlmIGFuYWx5c2lzIGhhc24ndCBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgICAgICBnZXQoKS5mYWlsQW5hbHlzaXMoYW5hbHlzaXNJZCwge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gbG9zdCBkdXJpbmcgYW5hbHlzaXMnLFxuICAgICAgICAgICAgICAgICAgY29kZTogJ0NPTk5FQ1RJT05fRVJST1InLFxuICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1NTRSBlcnJvciBhZnRlciBjb21wbGV0aW9uIC0gaWdub3JpbmcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FuYWx5c2lzIGNvbXBsZXRlZCB2aWEgU1NFJyk7XG4gICAgICAgICAgICAgIGdldCgpLmNvbXBsZXRlQW5hbHlzaXMoYW5hbHlzaXNJZCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFN0b3JlIGV2ZW50IHNvdXJjZSBmb3IgY2xlYW51cFxuICAgICAgICAgIHNldCh7IGV2ZW50U291cmNlIH0pO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBzdGFydCBhbmFseXNpcycsXG4gICAgICAgICAgICAgIGNvZGU6ICdBUElfRVJST1InLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgY3VycmVudFBoYXNlOiAnaWRsZScsIC8vIFJlc2V0IHRvIGlkbGUgb24gZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdXBkYXRlQW5hbHlzaXNQcm9ncmVzczogKGFuYWx5c2lzSWQsIHByb2dyZXNzLCBwaGFzZSkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBpZiAoc3RhdGUuY3VycmVudEFuYWx5c2lzPy5hbmFseXNpc19pZCA9PT0gYW5hbHlzaXNJZCkge1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBjdXJyZW50QW5hbHlzaXM6IHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUuY3VycmVudEFuYWx5c2lzLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdwcm9jZXNzaW5nJyxcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgICAgICBjdXJyZW50UGhhc2U6IHBoYXNlIGFzIEFuYWx5c2lzU3RhdGVbJ2N1cnJlbnRQaGFzZSddLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjb21wbGV0ZUFuYWx5c2lzOiBhc3luYyAoYW5hbHlzaXNJZCwgcmVzdWx0cykgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBpZiAoc3RhdGUuY3VycmVudEFuYWx5c2lzPy5hbmFseXNpc19pZCA9PT0gYW5hbHlzaXNJZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgZnVsbCBhbmFseXNpcyByZXN1bHRzIGZyb20gdGhlIEFQSVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBBbmFseXNpc1NlcnZpY2UuZ2V0QW5hbHlzaXNSZXN1bHQoYW5hbHlzaXNJZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVkQW5hbHlzaXM6IEFuYWx5c2lzUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLmN1cnJlbnRBbmFseXNpcyxcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZS5kYXRhLCAvLyBVc2UgdGhlIHByb3Blcmx5IG1hcHBlZCBkYXRhIGZyb20gdGhlIHNlcnZpY2VcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBbmFseXNpczogY29tcGxldGVkQW5hbHlzaXMsXG4gICAgICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UGhhc2U6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBpbiBoaXN0b3J5XG4gICAgICAgICAgICAgIGdldCgpLmFkZFRvSGlzdG9yeShjb21wbGV0ZWRBbmFseXNpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byB0aGUgcmVzdWx0cyBwYXNzZWQgaW4gKGlmIGFueSlcbiAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVkQW5hbHlzaXM6IEFuYWx5c2lzUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLmN1cnJlbnRBbmFseXNpcyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXG4gICAgICAgICAgICAgICAgcmVzdWx0czogcmVzdWx0cyB8fCB7XG4gICAgICAgICAgICAgICAgICBiaW9tYXJrZXJzOiBbXSxcbiAgICAgICAgICAgICAgICAgIGNsdXN0ZXJzOiBbXSxcbiAgICAgICAgICAgICAgICAgIGluc2lnaHRzOiBbXSxcbiAgICAgICAgICAgICAgICAgIHJpc2tfYXNzZXNzbWVudDoge30sXG4gICAgICAgICAgICAgICAgICByZWNvbW1lbmRhdGlvbnM6IFtdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBbmFseXNpczogY29tcGxldGVkQW5hbHlzaXMsXG4gICAgICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UGhhc2U6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBpbiBoaXN0b3J5XG4gICAgICAgICAgICAgIGdldCgpLmFkZFRvSGlzdG9yeShjb21wbGV0ZWRBbmFseXNpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBhbmFseXNpcyByZXN1bHRzOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHRoZSByZXN1bHRzIHBhc3NlZCBpbiAoaWYgYW55KVxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVkQW5hbHlzaXM6IEFuYWx5c2lzUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAuLi5zdGF0ZS5jdXJyZW50QW5hbHlzaXMsXG4gICAgICAgICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXG4gICAgICAgICAgICAgIHJlc3VsdHM6IHJlc3VsdHMgfHwge1xuICAgICAgICAgICAgICAgIGJpb21hcmtlcnM6IFtdLFxuICAgICAgICAgICAgICAgIGNsdXN0ZXJzOiBbXSxcbiAgICAgICAgICAgICAgICBpbnNpZ2h0czogW10sXG4gICAgICAgICAgICAgICAgcmlza19hc3Nlc3NtZW50OiB7fSxcbiAgICAgICAgICAgICAgICByZWNvbW1lbmRhdGlvbnM6IFtdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNvbXBsZXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgY3VycmVudEFuYWx5c2lzOiBjb21wbGV0ZWRBbmFseXNpcyxcbiAgICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgY3VycmVudFBoYXNlOiAnY29tcGxldGVkJyxcbiAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGluIGhpc3RvcnlcbiAgICAgICAgICAgIGdldCgpLmFkZFRvSGlzdG9yeShjb21wbGV0ZWRBbmFseXNpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vIGN1cnJlbnQgYW5hbHlzaXMsIGp1c3QgdXBkYXRlIHRoZSBwaGFzZSBhbmQgcHJvZ3Jlc3NcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnJlbnRQaGFzZTogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICBwcm9ncmVzczogMTAwLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGZhaWxBbmFseXNpczogKGFuYWx5c2lzSWQsIGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50QW5hbHlzaXM/LmFuYWx5c2lzX2lkID09PSBhbmFseXNpc0lkKSB7XG4gICAgICAgICAgY29uc3QgZmFpbGVkQW5hbHlzaXM6IEFuYWx5c2lzUmVzdWx0ID0ge1xuICAgICAgICAgICAgLi4uc3RhdGUuY3VycmVudEFuYWx5c2lzLFxuICAgICAgICAgICAgc3RhdHVzOiAnZmFpbGVkJyxcbiAgICAgICAgICAgIGNvbXBsZXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgY3VycmVudEFuYWx5c2lzOiBmYWlsZWRBbmFseXNpcyxcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBjdXJyZW50UGhhc2U6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBpbiBoaXN0b3J5XG4gICAgICAgICAgZ2V0KCkuYWRkVG9IaXN0b3J5KGZhaWxlZEFuYWx5c2lzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBubyBjdXJyZW50IGFuYWx5c2lzLCBqdXN0IHVwZGF0ZSB0aGUgcGhhc2UgYW5kIGVycm9yXG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBjdXJyZW50UGhhc2U6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY2xlYXJBbmFseXNpczogKCkgPT4ge1xuICAgICAgICAvLyBDbG9zZSBhbnkgYWN0aXZlIFNTRSBjb25uZWN0aW9uXG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5ldmVudFNvdXJjZSkge1xuICAgICAgICAgIHN0YXRlLmV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNldCh7XG4gICAgICAgICAgY3VycmVudEFuYWx5c2lzOiBudWxsLFxuICAgICAgICAgIGN1cnJlbnRBbmFseXNpc0lkOiBudWxsLFxuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgY3VycmVudFBoYXNlOiAnaWRsZScsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgcmF3QmlvbWFya2Vyczoge30sXG4gICAgICAgICAgbm9ybWFsaXplZEJpb21hcmtlcnM6IHt9LFxuICAgICAgICAgIHVubWFwcGVkQmlvbWFya2VyczogW10sXG4gICAgICAgICAgcXVlc3Rpb25uYWlyZVJlc3BvbnNlczoge30sXG4gICAgICAgICAgcXVlc3Rpb25uYWlyZUNvbXBsZXRlZDogZmFsc2UsXG4gICAgICAgICAgZXZlbnRTb3VyY2U6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgcmV0cnlBbmFseXNpczogKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBpZiAoc3RhdGUuY3VycmVudEFuYWx5c2lzICYmIHN0YXRlLnVzZXJQcm9maWxlKSB7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdDogQW5hbHlzaXNSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgYmlvbWFya2Vyczogc3RhdGUucmF3QmlvbWFya2VycyxcbiAgICAgICAgICAgIHVzZXI6IHN0YXRlLnVzZXJQcm9maWxlLFxuICAgICAgICAgICAgcXVlc3Rpb25uYWlyZTogc3RhdGUucXVlc3Rpb25uYWlyZVJlc3BvbnNlcyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdldCgpLnN0YXJ0QW5hbHlzaXMocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG4gICAgICBnZXRBbmFseXNpc0J5SWQ6IChhbmFseXNpc0lkKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5hbmFseXNpc0hpc3RvcnkuZmluZChhbmFseXNpcyA9PiBhbmFseXNpcy5hbmFseXNpc19pZCA9PT0gYW5hbHlzaXNJZCk7XG4gICAgICB9LFxuXG4gICAgICBnZXRSZWNlbnRBbmFseXNlczogKGxpbWl0ID0gMTApID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmFuYWx5c2lzSGlzdG9yeS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICB9LFxuXG4gICAgICBpc0FuYWx5c2lzQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmN1cnJlbnRBbmFseXNpcz8uc3RhdHVzID09PSAnY29tcGxldGVkJztcbiAgICAgIH0sXG5cbiAgICAgIGdldEFuYWx5c2lzU3VtbWFyeTogKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBjb25zdCBhbmFseXNlcyA9IHN0YXRlLmFuYWx5c2lzSGlzdG9yeTtcbiAgICAgICAgY29uc3QgY29tcGxldGVkID0gYW5hbHlzZXMuZmlsdGVyKGEgPT4gYS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKTtcbiAgICAgICAgY29uc3QgZmFpbGVkID0gYW5hbHlzZXMuZmlsdGVyKGEgPT4gYS5zdGF0dXMgPT09ICdmYWlsZWQnKTtcbiAgICAgICAgY29uc3Qgc2NvcmVzID0gY29tcGxldGVkXG4gICAgICAgICAgLm1hcChhID0+IGEucmVzdWx0cz8ub3ZlcmFsbF9zY29yZSlcbiAgICAgICAgICAuZmlsdGVyKHNjb3JlID0+IHR5cGVvZiBzY29yZSA9PT0gJ251bWJlcicpIGFzIG51bWJlcltdO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3RhbEFuYWx5c2VzOiBhbmFseXNlcy5sZW5ndGgsXG4gICAgICAgICAgY29tcGxldGVkQW5hbHlzZXM6IGNvbXBsZXRlZC5sZW5ndGgsXG4gICAgICAgICAgZmFpbGVkQW5hbHlzZXM6IGZhaWxlZC5sZW5ndGgsXG4gICAgICAgICAgYXZlcmFnZVNjb3JlOiBzY29yZXMubGVuZ3RoID4gMCA/IHNjb3Jlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHNjb3Jlcy5sZW5ndGggOiAwLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9KSxcbiAgICB7XG4gICAgICBuYW1lOiAnYW5hbHlzaXMtc3RvcmUnLFxuICAgIH1cbiAgKVxuKTtcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJkZXZ0b29scyIsIkFuYWx5c2lzU2VydmljZSIsInVzZUFuYWx5c2lzU3RvcmUiLCJzZXQiLCJnZXQiLCJjdXJyZW50QW5hbHlzaXMiLCJjdXJyZW50QW5hbHlzaXNJZCIsImFuYWx5c2lzSGlzdG9yeSIsImlzTG9hZGluZyIsImVycm9yIiwiY3VycmVudFBoYXNlIiwicHJvZ3Jlc3MiLCJyYXdCaW9tYXJrZXJzIiwibm9ybWFsaXplZEJpb21hcmtlcnMiLCJ1bm1hcHBlZEJpb21hcmtlcnMiLCJ1c2VyUHJvZmlsZSIsInF1ZXN0aW9ubmFpcmVSZXNwb25zZXMiLCJxdWVzdGlvbm5haXJlQ29tcGxldGVkIiwiZXZlbnRTb3VyY2UiLCJzZXRDdXJyZW50QW5hbHlzaXMiLCJhbmFseXNpcyIsInNldEN1cnJlbnRBbmFseXNpc0lkIiwiYW5hbHlzaXNJZCIsImFkZFRvSGlzdG9yeSIsInN0YXRlIiwic2xpY2UiLCJzZXRMb2FkaW5nIiwibG9hZGluZyIsInNldEVycm9yIiwic2V0UGhhc2UiLCJwaGFzZSIsInNldFByb2dyZXNzIiwiTWF0aCIsIm1heCIsIm1pbiIsInNldFJhd0Jpb21hcmtlcnMiLCJiaW9tYXJrZXJzIiwic2V0Tm9ybWFsaXplZEJpb21hcmtlcnMiLCJzZXRVbm1hcHBlZEJpb21hcmtlcnMiLCJ1bm1hcHBlZCIsInNldFVzZXJQcm9maWxlIiwicHJvZmlsZSIsInNldFF1ZXN0aW9ubmFpcmVSZXNwb25zZXMiLCJyZXNwb25zZXMiLCJzZXRRdWVzdGlvbm5haXJlQ29tcGxldGVkIiwiY29tcGxldGVkIiwic2V0UmVzcG9uc2UiLCJpZCIsInZhbHVlIiwiZ2V0UmVzcG9uc2UiLCJyZXNldFJlc3BvbnNlcyIsInN0YXJ0QW5hbHlzaXMiLCJyZXF1ZXN0IiwiYmlvbWFya2VyVmFsaWRhdGlvbiIsInZhbGlkYXRlQmlvbWFya2VyRGF0YSIsInVzZXJWYWxpZGF0aW9uIiwidmFsaWRhdGVVc2VyUHJvZmlsZSIsInVzZXIiLCJ2YWxpZCIsImVycm9ycyIsIm1lc3NhZ2UiLCJqb2luIiwiY29kZSIsImRldGFpbHMiLCJiaW9tYXJrZXJFcnJvcnMiLCJ1c2VyRXJyb3JzIiwicXVlc3Rpb25uYWlyZSIsInJlc3BvbnNlIiwic3VjY2VzcyIsIkVycm9yIiwiZGF0YSIsImFuYWx5c2lzX2lkIiwic3RhdHVzIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInN1YnNjcmliZVRvQW5hbHlzaXNFdmVudHMiLCJldmVudCIsIkpTT04iLCJwYXJzZSIsImNvbnNvbGUiLCJsb2ciLCJ1cGRhdGVBbmFseXNpc1Byb2dyZXNzIiwiY29tcGxldGVBbmFseXNpcyIsInJlc3VsdHMiLCJ0eXBlIiwiZmFpbEFuYWx5c2lzIiwiZ2V0QW5hbHlzaXNSZXN1bHQiLCJjb21wbGV0ZWRBbmFseXNpcyIsImNvbXBsZXRlZF9hdCIsImNsdXN0ZXJzIiwiaW5zaWdodHMiLCJyaXNrX2Fzc2Vzc21lbnQiLCJyZWNvbW1lbmRhdGlvbnMiLCJmYWlsZWRBbmFseXNpcyIsImNsZWFyQW5hbHlzaXMiLCJjbG9zZSIsInJldHJ5QW5hbHlzaXMiLCJnZXRBbmFseXNpc0J5SWQiLCJmaW5kIiwiZ2V0UmVjZW50QW5hbHlzZXMiLCJsaW1pdCIsImlzQW5hbHlzaXNDb21wbGV0ZSIsImdldEFuYWx5c2lzU3VtbWFyeSIsImFuYWx5c2VzIiwiZmlsdGVyIiwiYSIsImZhaWxlZCIsInNjb3JlcyIsIm1hcCIsIm92ZXJhbGxfc2NvcmUiLCJzY29yZSIsInRvdGFsQW5hbHlzZXMiLCJsZW5ndGgiLCJjb21wbGV0ZWRBbmFseXNlcyIsImZhaWxlZEFuYWx5c2VzIiwiYXZlcmFnZVNjb3JlIiwicmVkdWNlIiwiYiIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/state/analysisStore.ts\n"));

/***/ })

});