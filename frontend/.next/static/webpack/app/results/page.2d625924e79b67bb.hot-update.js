"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/results/page",{

/***/ "(app-pages-browser)/./app/state/analysisStore.ts":
/*!************************************!*\
  !*** ./app/state/analysisStore.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAnalysisStore: function() { return /* binding */ useAnalysisStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _services_analysis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/analysis */ \"(app-pages-browser)/./app/services/analysis.ts\");\n\n\n\nconst useAnalysisStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.devtools)((set, get)=>({\n        // Initial state\n        currentAnalysis: null,\n        currentAnalysisId: null,\n        analysisHistory: [],\n        isLoading: false,\n        error: null,\n        currentPhase: \"idle\",\n        progress: 0,\n        rawBiomarkers: {},\n        normalizedBiomarkers: {},\n        unmappedBiomarkers: [],\n        userProfile: null,\n        questionnaireResponses: {},\n        questionnaireCompleted: false,\n        eventSource: null,\n        // Basic setters\n        setCurrentAnalysis: (analysis)=>set({\n                currentAnalysis: analysis\n            }),\n        setCurrentAnalysisId: (analysisId)=>set({\n                currentAnalysisId: analysisId\n            }),\n        addToHistory: (analysis)=>set((state)=>({\n                    analysisHistory: [\n                        analysis,\n                        ...state.analysisHistory.slice(0, 49)\n                    ] // Keep last 50\n                })),\n        setLoading: (loading)=>set({\n                isLoading: loading\n            }),\n        setError: (error)=>set({\n                error\n            }),\n        setPhase: (phase)=>set({\n                currentPhase: phase\n            }),\n        setProgress: (progress)=>set({\n                progress: Math.max(0, Math.min(100, progress))\n            }),\n        setRawBiomarkers: (biomarkers)=>set({\n                rawBiomarkers: biomarkers\n            }),\n        setNormalizedBiomarkers: (biomarkers)=>set({\n                normalizedBiomarkers: biomarkers\n            }),\n        setUnmappedBiomarkers: (unmapped)=>set({\n                unmappedBiomarkers: unmapped\n            }),\n        setUserProfile: (profile)=>set({\n                userProfile: profile\n            }),\n        setQuestionnaireResponses: (responses)=>set({\n                questionnaireResponses: responses\n            }),\n        setQuestionnaireCompleted: (completed)=>set({\n                questionnaireCompleted: completed\n            }),\n        // Questionnaire actions\n        setResponse: (id, value)=>set((state)=>({\n                    questionnaireResponses: {\n                        ...state.questionnaireResponses,\n                        [id]: value\n                    }\n                })),\n        getResponse: (id)=>{\n            const state = get();\n            return state.questionnaireResponses[id];\n        },\n        resetResponses: ()=>set({\n                questionnaireResponses: {}\n            }),\n        // Complex actions\n        startAnalysis: async (request)=>{\n            console.debug(\"[AnalysisStore] Starting analysis with request:\", request);\n            // Validate input data\n            const biomarkerValidation = _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.validateBiomarkerData(request.biomarkers);\n            const userValidation = _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.validateUserProfile(request.user);\n            console.debug(\"[AnalysisStore] Validation results:\", {\n                biomarkerValidation,\n                userValidation\n            });\n            if (!biomarkerValidation.valid || !userValidation.valid) {\n                const errors = [\n                    ...biomarkerValidation.errors,\n                    ...userValidation.errors\n                ];\n                console.error(\"[AnalysisStore] Validation failed:\", errors);\n                set({\n                    error: {\n                        message: \"Validation failed: \".concat(errors.join(\", \")),\n                        code: \"VALIDATION_ERROR\",\n                        details: {\n                            biomarkerErrors: biomarkerValidation.errors,\n                            userErrors: userValidation.errors\n                        }\n                    },\n                    isLoading: false,\n                    currentPhase: \"idle\"\n                });\n                return;\n            }\n            set({\n                isLoading: true,\n                error: null,\n                currentPhase: \"ingestion\",\n                progress: 0,\n                rawBiomarkers: request.biomarkers,\n                userProfile: request.user,\n                questionnaireResponses: request.questionnaire || {}\n            });\n            try {\n                // Call the API service\n                console.debug(\"[AnalysisStore] Calling AnalysisService.startAnalysis\");\n                const response = await _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.startAnalysis(request);\n                console.debug(\"[AnalysisStore] AnalysisService response:\", response);\n                if (!response.success) {\n                    throw new Error(response.error || \"Failed to start analysis\");\n                }\n                const analysisId = response.data.analysis_id;\n                const analysis = {\n                    analysis_id: analysisId,\n                    status: \"pending\",\n                    progress: 0,\n                    created_at: new Date().toISOString()\n                };\n                set({\n                    currentAnalysis: analysis,\n                    currentAnalysisId: analysisId,\n                    isLoading: false,\n                    error: null,\n                    currentPhase: \"ingestion\",\n                    progress: 0\n                });\n                // Add to history\n                get().addToHistory(analysis);\n                // Start listening to SSE events\n                const eventSource = _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.subscribeToAnalysisEvents(analysisId, (event)=>{\n                    try {\n                        const data = JSON.parse(event.data);\n                        console.log(\"SSE Event received:\", data);\n                        // Handle analysis_status events\n                        if (data.phase && typeof data.progress === \"number\") {\n                            get().updateAnalysisProgress(analysisId, data.progress, data.phase);\n                            // Check if this is a completion event\n                            if (data.phase === \"complete\") {\n                                get().completeAnalysis(analysisId, data.results);\n                            }\n                        } else if (data.type === \"complete\" || data.phase === \"complete\") {\n                            get().completeAnalysis(analysisId, data.results);\n                        } else if (data.type === \"error\" || data.error) {\n                            get().failAnalysis(analysisId, {\n                                message: data.message || data.error || \"Analysis failed\",\n                                code: data.code || \"ANALYSIS_ERROR\",\n                                details: data.details\n                            });\n                        }\n                    } catch (error) {\n                        console.error(\"Failed to parse SSE event:\", error);\n                    }\n                }, (error)=>{\n                    console.error(\"SSE connection error:\", error);\n                    // Only fail if analysis hasn't completed\n                    const state = get();\n                    if (state.currentPhase !== \"completed\") {\n                        get().failAnalysis(analysisId, {\n                            message: \"Connection lost during analysis\",\n                            code: \"CONNECTION_ERROR\",\n                            details: error\n                        });\n                    } else {\n                        console.log(\"SSE error after completion - ignoring\");\n                    }\n                }, ()=>{\n                    console.log(\"Analysis completed via SSE\");\n                    get().completeAnalysis(analysisId, null);\n                });\n                // Store event source for cleanup\n                set({\n                    eventSource\n                });\n            } catch (error) {\n                set({\n                    error: {\n                        message: error instanceof Error ? error.message : \"Failed to start analysis\",\n                        code: \"API_ERROR\",\n                        details: error\n                    },\n                    isLoading: false,\n                    currentPhase: \"idle\"\n                });\n            }\n        },\n        updateAnalysisProgress: (analysisId, progress, phase)=>{\n            var _state_currentAnalysis;\n            const state = get();\n            if (((_state_currentAnalysis = state.currentAnalysis) === null || _state_currentAnalysis === void 0 ? void 0 : _state_currentAnalysis.analysis_id) === analysisId) {\n                set({\n                    currentAnalysis: {\n                        ...state.currentAnalysis,\n                        status: \"processing\",\n                        progress\n                    },\n                    progress,\n                    currentPhase: phase\n                });\n            }\n        },\n        completeAnalysis: async (analysisId, results)=>{\n            var _state_currentAnalysis;\n            const state = get();\n            if (((_state_currentAnalysis = state.currentAnalysis) === null || _state_currentAnalysis === void 0 ? void 0 : _state_currentAnalysis.analysis_id) === analysisId) {\n                try {\n                    // Fetch the full analysis results from the API\n                    const response = await _services_analysis__WEBPACK_IMPORTED_MODULE_0__.AnalysisService.getAnalysisResult(analysisId);\n                    if (response && response.success && response.data) {\n                        const completedAnalysis = {\n                            ...state.currentAnalysis,\n                            ...response.data,\n                            completed_at: new Date().toISOString()\n                        };\n                        set({\n                            currentAnalysis: completedAnalysis,\n                            isLoading: false,\n                            currentPhase: \"completed\",\n                            progress: 100,\n                            error: null\n                        });\n                        // Update in history\n                        get().addToHistory(completedAnalysis);\n                    } else {\n                        // Fallback to the results passed in (if any)\n                        const completedAnalysis = {\n                            ...state.currentAnalysis,\n                            status: \"completed\",\n                            progress: 100,\n                            results: results || {\n                                biomarkers: [],\n                                clusters: [],\n                                insights: [],\n                                risk_assessment: {},\n                                recommendations: []\n                            },\n                            completed_at: new Date().toISOString()\n                        };\n                        set({\n                            currentAnalysis: completedAnalysis,\n                            isLoading: false,\n                            currentPhase: \"completed\",\n                            progress: 100,\n                            error: null\n                        });\n                        // Update in history\n                        get().addToHistory(completedAnalysis);\n                    }\n                } catch (error) {\n                    console.error(\"Failed to fetch analysis results:\", error);\n                    // Fallback to the results passed in (if any)\n                    const completedAnalysis = {\n                        ...state.currentAnalysis,\n                        status: \"completed\",\n                        progress: 100,\n                        results: results || {\n                            biomarkers: [],\n                            clusters: [],\n                            insights: [],\n                            risk_assessment: {},\n                            recommendations: []\n                        },\n                        completed_at: new Date().toISOString()\n                    };\n                    set({\n                        currentAnalysis: completedAnalysis,\n                        isLoading: false,\n                        currentPhase: \"completed\",\n                        progress: 100,\n                        error: null\n                    });\n                    // Update in history\n                    get().addToHistory(completedAnalysis);\n                }\n            } else {\n                // If no current analysis, just update the phase and progress\n                set({\n                    isLoading: false,\n                    currentPhase: \"completed\",\n                    progress: 100,\n                    error: null\n                });\n            }\n        },\n        failAnalysis: (analysisId, error)=>{\n            var _state_currentAnalysis;\n            const state = get();\n            if (((_state_currentAnalysis = state.currentAnalysis) === null || _state_currentAnalysis === void 0 ? void 0 : _state_currentAnalysis.analysis_id) === analysisId) {\n                const failedAnalysis = {\n                    ...state.currentAnalysis,\n                    status: \"failed\",\n                    completed_at: new Date().toISOString()\n                };\n                set({\n                    currentAnalysis: failedAnalysis,\n                    isLoading: false,\n                    currentPhase: \"error\",\n                    error\n                });\n                // Update in history\n                get().addToHistory(failedAnalysis);\n            } else {\n                // If no current analysis, just update the phase and error\n                set({\n                    isLoading: false,\n                    currentPhase: \"error\",\n                    error\n                });\n            }\n        },\n        clearAnalysis: ()=>{\n            // Close any active SSE connection\n            const state = get();\n            if (state.eventSource) {\n                state.eventSource.close();\n            }\n            set({\n                currentAnalysis: null,\n                currentAnalysisId: null,\n                isLoading: false,\n                error: null,\n                currentPhase: \"idle\",\n                progress: 0,\n                rawBiomarkers: {},\n                normalizedBiomarkers: {},\n                unmappedBiomarkers: [],\n                questionnaireResponses: {},\n                questionnaireCompleted: false,\n                eventSource: null\n            });\n        },\n        retryAnalysis: ()=>{\n            const state = get();\n            if (state.currentAnalysis && state.userProfile) {\n                const request = {\n                    biomarkers: state.rawBiomarkers,\n                    user: state.userProfile,\n                    questionnaire: state.questionnaireResponses\n                };\n                get().startAnalysis(request);\n            }\n        },\n        // Utility functions\n        getAnalysisById: (analysisId)=>{\n            const state = get();\n            return state.analysisHistory.find((analysis)=>analysis.analysis_id === analysisId);\n        },\n        getRecentAnalyses: function() {\n            let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n            const state = get();\n            return state.analysisHistory.slice(0, limit);\n        },\n        isAnalysisComplete: ()=>{\n            var _state_currentAnalysis;\n            const state = get();\n            return ((_state_currentAnalysis = state.currentAnalysis) === null || _state_currentAnalysis === void 0 ? void 0 : _state_currentAnalysis.status) === \"completed\";\n        },\n        getAnalysisSummary: ()=>{\n            const state = get();\n            const analyses = state.analysisHistory;\n            const completed = analyses.filter((a)=>a.status === \"completed\");\n            const failed = analyses.filter((a)=>a.status === \"failed\");\n            const scores = completed.map((a)=>{\n                var _a_results;\n                return (_a_results = a.results) === null || _a_results === void 0 ? void 0 : _a_results.overall_score;\n            }).filter((score)=>typeof score === \"number\");\n            return {\n                totalAnalyses: analyses.length,\n                completedAnalyses: completed.length,\n                failedAnalyses: failed.length,\n                averageScore: scores.length > 0 ? scores.reduce((a, b)=>a + b, 0) / scores.length : 0\n            };\n        }\n    }), {\n    name: \"analysis-store\"\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zdGF0ZS9hbmFseXNpc1N0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7QUFDYTtBQUNTO0FBNEdoRCxNQUFNRyxtQkFBbUJILCtDQUFNQSxHQUNwQ0MsNERBQVFBLENBQ04sQ0FBQ0csS0FBS0MsTUFBUztRQUNiLGdCQUFnQjtRQUNoQkMsaUJBQWlCO1FBQ2pCQyxtQkFBbUI7UUFDbkJDLGlCQUFpQixFQUFFO1FBQ25CQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsY0FBYztRQUNkQyxVQUFVO1FBQ1ZDLGVBQWUsQ0FBQztRQUNoQkMsc0JBQXNCLENBQUM7UUFDdkJDLG9CQUFvQixFQUFFO1FBQ3RCQyxhQUFhO1FBQ2JDLHdCQUF3QixDQUFDO1FBQ3pCQyx3QkFBd0I7UUFDeEJDLGFBQWE7UUFFYixnQkFBZ0I7UUFDaEJDLG9CQUFvQixDQUFDQyxXQUFhakIsSUFBSTtnQkFBRUUsaUJBQWlCZTtZQUFTO1FBRWxFQyxzQkFBc0IsQ0FBQ0MsYUFBZW5CLElBQUk7Z0JBQUVHLG1CQUFtQmdCO1lBQVc7UUFFMUVDLGNBQWMsQ0FBQ0gsV0FBYWpCLElBQUksQ0FBQ3FCLFFBQVc7b0JBQzFDakIsaUJBQWlCO3dCQUFDYTsyQkFBYUksTUFBTWpCLGVBQWUsQ0FBQ2tCLEtBQUssQ0FBQyxHQUFHO3FCQUFJLENBQUMsZUFBZTtnQkFDcEY7UUFFQUMsWUFBWSxDQUFDQyxVQUFZeEIsSUFBSTtnQkFBRUssV0FBV21CO1lBQVE7UUFFbERDLFVBQVUsQ0FBQ25CLFFBQVVOLElBQUk7Z0JBQUVNO1lBQU07UUFFakNvQixVQUFVLENBQUNDLFFBQVUzQixJQUFJO2dCQUFFTyxjQUFjb0I7WUFBTTtRQUUvQ0MsYUFBYSxDQUFDcEIsV0FBYVIsSUFBSTtnQkFBRVEsVUFBVXFCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBS3ZCO1lBQVc7UUFFaEZ3QixrQkFBa0IsQ0FBQ0MsYUFBZWpDLElBQUk7Z0JB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aEUsVUFDWmlFLEdBQUcsQ0FBQ0gsQ0FBQUE7b0JBQUtBO3dCQUFBQSxhQUFBQSxFQUFFdEIsT0FBTyxjQUFUc0IsaUNBQUFBLFdBQVdJLGFBQWE7ZUFDakNMLE1BQU0sQ0FBQ00sQ0FBQUEsUUFBUyxPQUFPQSxVQUFVO1lBRXBDLE9BQU87Z0JBQ0xDLGVBQWVSLFNBQVNTLE1BQU07Z0JBQzlCQyxtQkFBbUJ0RSxVQUFVcUUsTUFBTTtnQkFDbkNFLGdCQUFnQlIsT0FBT00sTUFBTTtnQkFDN0JHLGNBQWNSLE9BQU9LLE1BQU0sR0FBRyxJQUFJTCxPQUFPUyxNQUFNLENBQUMsQ0FBQ1gsR0FBR1ksSUFBTVosSUFBSVksR0FBRyxLQUFLVixPQUFPSyxNQUFNLEdBQUc7WUFDeEY7UUFDRjtJQUNGLElBQ0E7SUFDRU0sTUFBTTtBQUNSLElBRUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3N0YXRlL2FuYWx5c2lzU3RvcmUudHM/ZTA3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCB7IGRldnRvb2xzIH0gZnJvbSAnenVzdGFuZC9taWRkbGV3YXJlJztcbmltcG9ydCB7IEFuYWx5c2lzU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FuYWx5c2lzJztcbmltcG9ydCB7IEJpb21hcmtlclZhbHVlLCBCaW9tYXJrZXJEYXRhLCBVc2VyUHJvZmlsZSwgQW5hbHlzaXNSZXF1ZXN0IH0gZnJvbSAnLi4vdHlwZXMvYW5hbHlzaXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJpb21hcmtlclJlc3VsdCB7XG4gIGJpb21hcmtlcl9uYW1lOiBzdHJpbmc7XG4gIHZhbHVlOiBudW1iZXI7XG4gIHVuaXQ6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcGVyY2VudGlsZT86IG51bWJlcjtcbiAgc3RhdHVzOiAnb3B0aW1hbCcgfCAnbm9ybWFsJyB8ICdlbGV2YXRlZCcgfCAnbG93JyB8ICdjcml0aWNhbCc7XG4gIHJlZmVyZW5jZV9yYW5nZT86IHtcbiAgICBtaW46IG51bWJlcjtcbiAgICBtYXg6IG51bWJlcjtcbiAgICB1bml0OiBzdHJpbmc7XG4gIH07XG4gIGludGVycHJldGF0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQW5hbHlzaXNSZXN1bHQge1xuICBhbmFseXNpc19pZDogc3RyaW5nO1xuICBzdGF0dXM6ICdwZW5kaW5nJyB8ICdwcm9jZXNzaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2ZhaWxlZCc7XG4gIHByb2dyZXNzPzogbnVtYmVyO1xuICByZXN1bHRzPzoge1xuICAgIGJpb21hcmtlcnM6IEJpb21hcmtlclJlc3VsdFtdO1xuICAgIGNsdXN0ZXJzOiBhbnlbXTtcbiAgICBpbnNpZ2h0czogYW55W107XG4gICAgb3ZlcmFsbF9zY29yZT86IG51bWJlcjtcbiAgICByaXNrX2Fzc2Vzc21lbnQ6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXTtcbiAgfTtcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICBjb21wbGV0ZWRfYXQ/OiBzdHJpbmc7XG4gIHByb2Nlc3NpbmdfdGltZV9zZWNvbmRzPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5c2lzRXJyb3Ige1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIGNvZGU6IHN0cmluZztcbiAgZGV0YWlscz86IGFueTtcbn1cblxuaW50ZXJmYWNlIEFuYWx5c2lzU3RhdGUge1xuICAvLyBDdXJyZW50IGFuYWx5c2lzIHN0YXRlXG4gIGN1cnJlbnRBbmFseXNpczogQW5hbHlzaXNSZXN1bHQgfCBudWxsO1xuICBjdXJyZW50QW5hbHlzaXNJZDogc3RyaW5nIHwgbnVsbDtcbiAgYW5hbHlzaXNIaXN0b3J5OiBBbmFseXNpc1Jlc3VsdFtdO1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIGVycm9yOiBBbmFseXNpc0Vycm9yIHwgbnVsbDtcbiAgXG4gIC8vIEFuYWx5c2lzIHdvcmtmbG93IHN0YXRlXG4gIGN1cnJlbnRQaGFzZTogJ2lkbGUnIHwgJ2luZ2VzdGlvbicgfCAnbm9ybWFsaXphdGlvbicgfCAnc2NvcmluZycgfCAnY2x1c3RlcmluZycgfCAnaW5zaWdodHMnIHwgJ2NvbXBsZXRlZCcgfCAnZXJyb3InO1xuICBwcm9ncmVzczogbnVtYmVyO1xuICBcbiAgLy8gQmlvbWFya2VyIGRhdGEgc3RhdGVcbiAgcmF3QmlvbWFya2VyczogQmlvbWFya2VyRGF0YTtcbiAgbm9ybWFsaXplZEJpb21hcmtlcnM6IEJpb21hcmtlckRhdGE7XG4gIHVubWFwcGVkQmlvbWFya2Vyczogc3RyaW5nW107XG4gIFxuICAvLyBVc2VyIGNvbnRleHRcbiAgdXNlclByb2ZpbGU6IFVzZXJQcm9maWxlIHwgbnVsbDtcbiAgXG4gIC8vIFF1ZXN0aW9ubmFpcmUgc3RhdGVcbiAgcXVlc3Rpb25uYWlyZVJlc3BvbnNlczogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgcXVlc3Rpb25uYWlyZUNvbXBsZXRlZDogYm9vbGVhbjtcbiAgXG4gIC8vIFNTRSBjb25uZWN0aW9uXG4gIGV2ZW50U291cmNlOiBFdmVudFNvdXJjZSB8IG51bGw7XG4gIFxuICAvLyBBY3Rpb25zXG4gIHNldEN1cnJlbnRBbmFseXNpczogKGFuYWx5c2lzOiBBbmFseXNpc1Jlc3VsdCB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEN1cnJlbnRBbmFseXNpc0lkOiAoYW5hbHlzaXNJZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgYWRkVG9IaXN0b3J5OiAoYW5hbHlzaXM6IEFuYWx5c2lzUmVzdWx0KSA9PiB2b2lkO1xuICBzZXRMb2FkaW5nOiAobG9hZGluZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0RXJyb3I6IChlcnJvcjogQW5hbHlzaXNFcnJvciB8IG51bGwpID0+IHZvaWQ7XG4gIHNldFBoYXNlOiAocGhhc2U6IEFuYWx5c2lzU3RhdGVbJ2N1cnJlbnRQaGFzZSddKSA9PiB2b2lkO1xuICBzZXRQcm9ncmVzczogKHByb2dyZXNzOiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldFJhd0Jpb21hcmtlcnM6IChiaW9tYXJrZXJzOiBCaW9tYXJrZXJEYXRhKSA9PiB2b2lkO1xuICBzZXROb3JtYWxpemVkQmlvbWFya2VyczogKGJpb21hcmtlcnM6IEJpb21hcmtlckRhdGEpID0+IHZvaWQ7XG4gIHNldFVubWFwcGVkQmlvbWFya2VyczogKHVubWFwcGVkOiBzdHJpbmdbXSkgPT4gdm9pZDtcbiAgc2V0VXNlclByb2ZpbGU6IChwcm9maWxlOiBVc2VyUHJvZmlsZSB8IG51bGwpID0+IHZvaWQ7XG4gIHNldFF1ZXN0aW9ubmFpcmVSZXNwb25zZXM6IChyZXNwb25zZXM6IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IHZvaWQ7XG4gIHNldFF1ZXN0aW9ubmFpcmVDb21wbGV0ZWQ6IChjb21wbGV0ZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIFxuICAvLyBDb21wbGV4IGFjdGlvbnNcbiAgc3RhcnRBbmFseXNpczogKHJlcXVlc3Q6IEFuYWx5c2lzUmVxdWVzdCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgdXBkYXRlQW5hbHlzaXNQcm9ncmVzczogKGFuYWx5c2lzSWQ6IHN0cmluZywgcHJvZ3Jlc3M6IG51bWJlciwgcGhhc2U6IHN0cmluZykgPT4gdm9pZDtcbiAgY29tcGxldGVBbmFseXNpczogKGFuYWx5c2lzSWQ6IHN0cmluZywgcmVzdWx0czogQW5hbHlzaXNSZXN1bHRbJ3Jlc3VsdHMnXSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZmFpbEFuYWx5c2lzOiAoYW5hbHlzaXNJZDogc3RyaW5nLCBlcnJvcjogQW5hbHlzaXNFcnJvcikgPT4gdm9pZDtcbiAgY2xlYXJBbmFseXNpczogKCkgPT4gdm9pZDtcbiAgcmV0cnlBbmFseXNpczogKCkgPT4gdm9pZDtcbiAgXG4gIC8vIFF1ZXN0aW9ubmFpcmUgYWN0aW9uc1xuICBzZXRSZXNwb25zZTogKGlkOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHZvaWQ7XG4gIGdldFJlc3BvbnNlOiAoaWQ6IHN0cmluZykgPT4gYW55O1xuICByZXNldFJlc3BvbnNlczogKCkgPT4gdm9pZDtcbiAgXG4gIC8vIFV0aWxpdHkgYWN0aW9uc1xuICBnZXRBbmFseXNpc0J5SWQ6IChhbmFseXNpc0lkOiBzdHJpbmcpID0+IEFuYWx5c2lzUmVzdWx0IHwgdW5kZWZpbmVkO1xuICBnZXRSZWNlbnRBbmFseXNlczogKGxpbWl0PzogbnVtYmVyKSA9PiBBbmFseXNpc1Jlc3VsdFtdO1xuICBpc0FuYWx5c2lzQ29tcGxldGU6ICgpID0+IGJvb2xlYW47XG4gIGdldEFuYWx5c2lzU3VtbWFyeTogKCkgPT4ge1xuICAgIHRvdGFsQW5hbHlzZXM6IG51bWJlcjtcbiAgICBjb21wbGV0ZWRBbmFseXNlczogbnVtYmVyO1xuICAgIGZhaWxlZEFuYWx5c2VzOiBudW1iZXI7XG4gICAgYXZlcmFnZVNjb3JlOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCB1c2VBbmFseXNpc1N0b3JlID0gY3JlYXRlPEFuYWx5c2lzU3RhdGU+KCkoXG4gIGRldnRvb2xzKFxuICAgIChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC8vIEluaXRpYWwgc3RhdGVcbiAgICAgIGN1cnJlbnRBbmFseXNpczogbnVsbCxcbiAgICAgIGN1cnJlbnRBbmFseXNpc0lkOiBudWxsLFxuICAgICAgYW5hbHlzaXNIaXN0b3J5OiBbXSxcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIGN1cnJlbnRQaGFzZTogJ2lkbGUnLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICByYXdCaW9tYXJrZXJzOiB7fSxcbiAgICAgIG5vcm1hbGl6ZWRCaW9tYXJrZXJzOiB7fSxcbiAgICAgIHVubWFwcGVkQmlvbWFya2VyczogW10sXG4gICAgICB1c2VyUHJvZmlsZTogbnVsbCxcbiAgICAgIHF1ZXN0aW9ubmFpcmVSZXNwb25zZXM6IHt9LFxuICAgICAgcXVlc3Rpb25uYWlyZUNvbXBsZXRlZDogZmFsc2UsXG4gICAgICBldmVudFNvdXJjZTogbnVsbCxcblxuICAgICAgLy8gQmFzaWMgc2V0dGVyc1xuICAgICAgc2V0Q3VycmVudEFuYWx5c2lzOiAoYW5hbHlzaXMpID0+IHNldCh7IGN1cnJlbnRBbmFseXNpczogYW5hbHlzaXMgfSksXG4gICAgICBcbiAgICAgIHNldEN1cnJlbnRBbmFseXNpc0lkOiAoYW5hbHlzaXNJZCkgPT4gc2V0KHsgY3VycmVudEFuYWx5c2lzSWQ6IGFuYWx5c2lzSWQgfSksXG4gICAgICBcbiAgICAgIGFkZFRvSGlzdG9yeTogKGFuYWx5c2lzKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICBhbmFseXNpc0hpc3Rvcnk6IFthbmFseXNpcywgLi4uc3RhdGUuYW5hbHlzaXNIaXN0b3J5LnNsaWNlKDAsIDQ5KV0gLy8gS2VlcCBsYXN0IDUwXG4gICAgICB9KSksXG4gICAgICBcbiAgICAgIHNldExvYWRpbmc6IChsb2FkaW5nKSA9PiBzZXQoeyBpc0xvYWRpbmc6IGxvYWRpbmcgfSksXG4gICAgICBcbiAgICAgIHNldEVycm9yOiAoZXJyb3IpID0+IHNldCh7IGVycm9yIH0pLFxuICAgICAgXG4gICAgICBzZXRQaGFzZTogKHBoYXNlKSA9PiBzZXQoeyBjdXJyZW50UGhhc2U6IHBoYXNlIH0pLFxuICAgICAgXG4gICAgICBzZXRQcm9ncmVzczogKHByb2dyZXNzKSA9PiBzZXQoeyBwcm9ncmVzczogTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBwcm9ncmVzcykpIH0pLFxuICAgICAgXG4gICAgICBzZXRSYXdCaW9tYXJrZXJzOiAoYmlvbWFya2VycykgPT4gc2V0KHsgcmF3QmlvbWFya2VyczogYmlvbWFya2VycyB9KSxcbiAgICAgIFxuICAgICAgc2V0Tm9ybWFsaXplZEJpb21hcmtlcnM6IChiaW9tYXJrZXJzKSA9PiBzZXQoeyBub3JtYWxpemVkQmlvbWFya2VyczogYmlvbWFya2VycyB9KSxcbiAgICAgIFxuICAgICAgc2V0VW5tYXBwZWRCaW9tYXJrZXJzOiAodW5tYXBwZWQpID0+IHNldCh7IHVubWFwcGVkQmlvbWFya2VyczogdW5tYXBwZWQgfSksXG4gICAgICBcbiAgICAgIHNldFVzZXJQcm9maWxlOiAocHJvZmlsZSkgPT4gc2V0KHsgdXNlclByb2ZpbGU6IHByb2ZpbGUgfSksXG4gICAgICBcbiAgICAgIHNldFF1ZXN0aW9ubmFpcmVSZXNwb25zZXM6IChyZXNwb25zZXMpID0+IHNldCh7IHF1ZXN0aW9ubmFpcmVSZXNwb25zZXM6IHJlc3BvbnNlcyB9KSxcbiAgICAgIFxuICAgICAgc2V0UXVlc3Rpb25uYWlyZUNvbXBsZXRlZDogKGNvbXBsZXRlZCkgPT4gc2V0KHsgcXVlc3Rpb25uYWlyZUNvbXBsZXRlZDogY29tcGxldGVkIH0pLFxuXG4gICAgICAvLyBRdWVzdGlvbm5haXJlIGFjdGlvbnNcbiAgICAgIHNldFJlc3BvbnNlOiAoaWQsIHZhbHVlKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICBxdWVzdGlvbm5haXJlUmVzcG9uc2VzOiB7IC4uLnN0YXRlLnF1ZXN0aW9ubmFpcmVSZXNwb25zZXMsIFtpZF06IHZhbHVlIH1cbiAgICAgIH0pKSxcbiAgICAgIFxuICAgICAgZ2V0UmVzcG9uc2U6IChpZCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICByZXR1cm4gc3RhdGUucXVlc3Rpb25uYWlyZVJlc3BvbnNlc1tpZF07XG4gICAgICB9LFxuICAgICAgXG4gICAgICByZXNldFJlc3BvbnNlczogKCkgPT4gc2V0KHsgcXVlc3Rpb25uYWlyZVJlc3BvbnNlczoge30gfSksXG5cbiAgICAgIC8vIENvbXBsZXggYWN0aW9uc1xuICAgICAgc3RhcnRBbmFseXNpczogYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0FuYWx5c2lzU3RvcmVdIFN0YXJ0aW5nIGFuYWx5c2lzIHdpdGggcmVxdWVzdDonLCByZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIGlucHV0IGRhdGFcbiAgICAgICAgY29uc3QgYmlvbWFya2VyVmFsaWRhdGlvbiA9IEFuYWx5c2lzU2VydmljZS52YWxpZGF0ZUJpb21hcmtlckRhdGEocmVxdWVzdC5iaW9tYXJrZXJzKTtcbiAgICAgICAgY29uc3QgdXNlclZhbGlkYXRpb24gPSBBbmFseXNpc1NlcnZpY2UudmFsaWRhdGVVc2VyUHJvZmlsZShyZXF1ZXN0LnVzZXIpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0FuYWx5c2lzU3RvcmVdIFZhbGlkYXRpb24gcmVzdWx0czonLCB7IGJpb21hcmtlclZhbGlkYXRpb24sIHVzZXJWYWxpZGF0aW9uIH0pO1xuXG4gICAgICAgIGlmICghYmlvbWFya2VyVmFsaWRhdGlvbi52YWxpZCB8fCAhdXNlclZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbLi4uYmlvbWFya2VyVmFsaWRhdGlvbi5lcnJvcnMsIC4uLnVzZXJWYWxpZGF0aW9uLmVycm9yc107XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW0FuYWx5c2lzU3RvcmVdIFZhbGlkYXRpb24gZmFpbGVkOicsIGVycm9ycyk7XG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBWYWxpZGF0aW9uIGZhaWxlZDogJHtlcnJvcnMuam9pbignLCAnKX1gLFxuICAgICAgICAgICAgICBjb2RlOiAnVkFMSURBVElPTl9FUlJPUicsXG4gICAgICAgICAgICAgIGRldGFpbHM6IHsgYmlvbWFya2VyRXJyb3JzOiBiaW9tYXJrZXJWYWxpZGF0aW9uLmVycm9ycywgdXNlckVycm9yczogdXNlclZhbGlkYXRpb24uZXJyb3JzIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnJlbnRQaGFzZTogJ2lkbGUnLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldCh7XG4gICAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIGN1cnJlbnRQaGFzZTogJ2luZ2VzdGlvbicsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgcmF3QmlvbWFya2VyczogcmVxdWVzdC5iaW9tYXJrZXJzLFxuICAgICAgICAgIHVzZXJQcm9maWxlOiByZXF1ZXN0LnVzZXIsXG4gICAgICAgICAgcXVlc3Rpb25uYWlyZVJlc3BvbnNlczogcmVxdWVzdC5xdWVzdGlvbm5haXJlIHx8IHt9LFxuICAgICAgICB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENhbGwgdGhlIEFQSSBzZXJ2aWNlXG4gICAgICAgICAgY29uc29sZS5kZWJ1ZygnW0FuYWx5c2lzU3RvcmVdIENhbGxpbmcgQW5hbHlzaXNTZXJ2aWNlLnN0YXJ0QW5hbHlzaXMnKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEFuYWx5c2lzU2VydmljZS5zdGFydEFuYWx5c2lzKHJlcXVlc3QpO1xuICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tBbmFseXNpc1N0b3JlXSBBbmFseXNpc1NlcnZpY2UgcmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdGYWlsZWQgdG8gc3RhcnQgYW5hbHlzaXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhbmFseXNpc0lkID0gcmVzcG9uc2UuZGF0YS5hbmFseXNpc19pZDtcbiAgICAgICAgICBjb25zdCBhbmFseXNpczogQW5hbHlzaXNSZXN1bHQgPSB7XG4gICAgICAgICAgICBhbmFseXNpc19pZDogYW5hbHlzaXNJZCxcbiAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBjdXJyZW50QW5hbHlzaXM6IGFuYWx5c2lzLFxuICAgICAgICAgICAgY3VycmVudEFuYWx5c2lzSWQ6IGFuYWx5c2lzSWQsXG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLCAvLyBTZXQgdG8gZmFsc2UgYWZ0ZXIgc3VjY2Vzc2Z1bCBzdGFydFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBjdXJyZW50UGhhc2U6ICdpbmdlc3Rpb24nLCAvLyBNb3ZlIHRvIGluZ2VzdGlvbiBwaGFzZVxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBBZGQgdG8gaGlzdG9yeVxuICAgICAgICAgIGdldCgpLmFkZFRvSGlzdG9yeShhbmFseXNpcyk7XG5cbiAgICAgICAgICAvLyBTdGFydCBsaXN0ZW5pbmcgdG8gU1NFIGV2ZW50c1xuICAgICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gQW5hbHlzaXNTZXJ2aWNlLnN1YnNjcmliZVRvQW5hbHlzaXNFdmVudHMoXG4gICAgICAgICAgICBhbmFseXNpc0lkLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1NTRSBFdmVudCByZWNlaXZlZDonLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYW5hbHlzaXNfc3RhdHVzIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBoYXNlICYmIHR5cGVvZiBkYXRhLnByb2dyZXNzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgZ2V0KCkudXBkYXRlQW5hbHlzaXNQcm9ncmVzcyhhbmFseXNpc0lkLCBkYXRhLnByb2dyZXNzLCBkYXRhLnBoYXNlKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNvbXBsZXRpb24gZXZlbnRcbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnBoYXNlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldCgpLmNvbXBsZXRlQW5hbHlzaXMoYW5hbHlzaXNJZCwgZGF0YS5yZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2NvbXBsZXRlJyB8fCBkYXRhLnBoYXNlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgICBnZXQoKS5jb21wbGV0ZUFuYWx5c2lzKGFuYWx5c2lzSWQsIGRhdGEucmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdlcnJvcicgfHwgZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgZ2V0KCkuZmFpbEFuYWx5c2lzKGFuYWx5c2lzSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGF0YS5tZXNzYWdlIHx8IGRhdGEuZXJyb3IgfHwgJ0FuYWx5c2lzIGZhaWxlZCcsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGRhdGEuY29kZSB8fCAnQU5BTFlTSVNfRVJST1InLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBkYXRhLmRldGFpbHMsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIFNTRSBldmVudDonLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignU1NFIGNvbm5lY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAvLyBPbmx5IGZhaWwgaWYgYW5hbHlzaXMgaGFzbid0IGNvbXBsZXRlZFxuICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudFBoYXNlICE9PSAnY29tcGxldGVkJykge1xuICAgICAgICAgICAgICAgIGdldCgpLmZhaWxBbmFseXNpcyhhbmFseXNpc0lkLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiBsb3N0IGR1cmluZyBhbmFseXNpcycsXG4gICAgICAgICAgICAgICAgICBjb2RlOiAnQ09OTkVDVElPTl9FUlJPUicsXG4gICAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU1NFIGVycm9yIGFmdGVyIGNvbXBsZXRpb24gLSBpZ25vcmluZycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQW5hbHlzaXMgY29tcGxldGVkIHZpYSBTU0UnKTtcbiAgICAgICAgICAgICAgZ2V0KCkuY29tcGxldGVBbmFseXNpcyhhbmFseXNpc0lkLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gU3RvcmUgZXZlbnQgc291cmNlIGZvciBjbGVhbnVwXG4gICAgICAgICAgc2V0KHsgZXZlbnRTb3VyY2UgfSk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIHN0YXJ0IGFuYWx5c2lzJyxcbiAgICAgICAgICAgICAgY29kZTogJ0FQSV9FUlJPUicsXG4gICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBjdXJyZW50UGhhc2U6ICdpZGxlJywgLy8gUmVzZXQgdG8gaWRsZSBvbiBlcnJvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGVBbmFseXNpc1Byb2dyZXNzOiAoYW5hbHlzaXNJZCwgcHJvZ3Jlc3MsIHBoYXNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50QW5hbHlzaXM/LmFuYWx5c2lzX2lkID09PSBhbmFseXNpc0lkKSB7XG4gICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIGN1cnJlbnRBbmFseXNpczoge1xuICAgICAgICAgICAgICAuLi5zdGF0ZS5jdXJyZW50QW5hbHlzaXMsXG4gICAgICAgICAgICAgIHN0YXR1czogJ3Byb2Nlc3NpbmcnLFxuICAgICAgICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgICAgIGN1cnJlbnRQaGFzZTogcGhhc2UgYXMgQW5hbHlzaXNTdGF0ZVsnY3VycmVudFBoYXNlJ10sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbXBsZXRlQW5hbHlzaXM6IGFzeW5jIChhbmFseXNpc0lkLCByZXN1bHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50QW5hbHlzaXM/LmFuYWx5c2lzX2lkID09PSBhbmFseXNpc0lkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBmdWxsIGFuYWx5c2lzIHJlc3VsdHMgZnJvbSB0aGUgQVBJXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEFuYWx5c2lzU2VydmljZS5nZXRBbmFseXNpc1Jlc3VsdChhbmFseXNpc0lkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZWRBbmFseXNpczogQW5hbHlzaXNSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUuY3VycmVudEFuYWx5c2lzLFxuICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlLmRhdGEsIC8vIFVzZSB0aGUgcHJvcGVybHkgbWFwcGVkIGRhdGEgZnJvbSB0aGUgc2VydmljZVxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgY3VycmVudEFuYWx5c2lzOiBjb21wbGV0ZWRBbmFseXNpcyxcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQaGFzZTogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gVXBkYXRlIGluIGhpc3RvcnlcbiAgICAgICAgICAgICAgZ2V0KCkuYWRkVG9IaXN0b3J5KGNvbXBsZXRlZEFuYWx5c2lzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHRoZSByZXN1bHRzIHBhc3NlZCBpbiAoaWYgYW55KVxuICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZWRBbmFseXNpczogQW5hbHlzaXNSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUuY3VycmVudEFuYWx5c2lzLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcbiAgICAgICAgICAgICAgICByZXN1bHRzOiByZXN1bHRzIHx8IHtcbiAgICAgICAgICAgICAgICAgIGJpb21hcmtlcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgY2x1c3RlcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgaW5zaWdodHM6IFtdLFxuICAgICAgICAgICAgICAgICAgcmlza19hc3Nlc3NtZW50OiB7fSxcbiAgICAgICAgICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgY3VycmVudEFuYWx5c2lzOiBjb21wbGV0ZWRBbmFseXNpcyxcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQaGFzZTogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gVXBkYXRlIGluIGhpc3RvcnlcbiAgICAgICAgICAgICAgZ2V0KCkuYWRkVG9IaXN0b3J5KGNvbXBsZXRlZEFuYWx5c2lzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGFuYWx5c2lzIHJlc3VsdHM6JywgZXJyb3IpO1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gdGhlIHJlc3VsdHMgcGFzc2VkIGluIChpZiBhbnkpXG4gICAgICAgICAgICBjb25zdCBjb21wbGV0ZWRBbmFseXNpczogQW5hbHlzaXNSZXN1bHQgPSB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLmN1cnJlbnRBbmFseXNpcyxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnY29tcGxldGVkJyxcbiAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDEwMCxcbiAgICAgICAgICAgICAgcmVzdWx0czogcmVzdWx0cyB8fCB7XG4gICAgICAgICAgICAgICAgYmlvbWFya2VyczogW10sXG4gICAgICAgICAgICAgICAgY2x1c3RlcnM6IFtdLFxuICAgICAgICAgICAgICAgIGluc2lnaHRzOiBbXSxcbiAgICAgICAgICAgICAgICByaXNrX2Fzc2Vzc21lbnQ6IHt9LFxuICAgICAgICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogW11cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY29tcGxldGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICBjdXJyZW50QW5hbHlzaXM6IGNvbXBsZXRlZEFuYWx5c2lzLFxuICAgICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICBjdXJyZW50UGhhc2U6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgICBwcm9ncmVzczogMTAwLFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgaW4gaGlzdG9yeVxuICAgICAgICAgICAgZ2V0KCkuYWRkVG9IaXN0b3J5KGNvbXBsZXRlZEFuYWx5c2lzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbm8gY3VycmVudCBhbmFseXNpcywganVzdCB1cGRhdGUgdGhlIHBoYXNlIGFuZCBwcm9ncmVzc1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgY3VycmVudFBoYXNlOiAnY29tcGxldGVkJyxcbiAgICAgICAgICAgIHByb2dyZXNzOiAxMDAsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZmFpbEFuYWx5c2lzOiAoYW5hbHlzaXNJZCwgZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRBbmFseXNpcz8uYW5hbHlzaXNfaWQgPT09IGFuYWx5c2lzSWQpIHtcbiAgICAgICAgICBjb25zdCBmYWlsZWRBbmFseXNpczogQW5hbHlzaXNSZXN1bHQgPSB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5jdXJyZW50QW5hbHlzaXMsXG4gICAgICAgICAgICBzdGF0dXM6ICdmYWlsZWQnLFxuICAgICAgICAgICAgY29tcGxldGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICBjdXJyZW50QW5hbHlzaXM6IGZhaWxlZEFuYWx5c2lzLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnJlbnRQaGFzZTogJ2Vycm9yJyxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGluIGhpc3RvcnlcbiAgICAgICAgICBnZXQoKS5hZGRUb0hpc3RvcnkoZmFpbGVkQW5hbHlzaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vIGN1cnJlbnQgYW5hbHlzaXMsIGp1c3QgdXBkYXRlIHRoZSBwaGFzZSBhbmQgZXJyb3JcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGN1cnJlbnRQaGFzZTogJ2Vycm9yJyxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjbGVhckFuYWx5c2lzOiAoKSA9PiB7XG4gICAgICAgIC8vIENsb3NlIGFueSBhY3RpdmUgU1NFIGNvbm5lY3Rpb25cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgaWYgKHN0YXRlLmV2ZW50U291cmNlKSB7XG4gICAgICAgICAgc3RhdGUuZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0KHtcbiAgICAgICAgICBjdXJyZW50QW5hbHlzaXM6IG51bGwsXG4gICAgICAgICAgY3VycmVudEFuYWx5c2lzSWQ6IG51bGwsXG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICBjdXJyZW50UGhhc2U6ICdpZGxlJyxcbiAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICByYXdCaW9tYXJrZXJzOiB7fSxcbiAgICAgICAgICBub3JtYWxpemVkQmlvbWFya2Vyczoge30sXG4gICAgICAgICAgdW5tYXBwZWRCaW9tYXJrZXJzOiBbXSxcbiAgICAgICAgICBxdWVzdGlvbm5haXJlUmVzcG9uc2VzOiB7fSxcbiAgICAgICAgICBxdWVzdGlvbm5haXJlQ29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgICBldmVudFNvdXJjZTogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICByZXRyeUFuYWx5c2lzOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50QW5hbHlzaXMgJiYgc3RhdGUudXNlclByb2ZpbGUpIHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0OiBBbmFseXNpc1JlcXVlc3QgPSB7XG4gICAgICAgICAgICBiaW9tYXJrZXJzOiBzdGF0ZS5yYXdCaW9tYXJrZXJzLFxuICAgICAgICAgICAgdXNlcjogc3RhdGUudXNlclByb2ZpbGUsXG4gICAgICAgICAgICBxdWVzdGlvbm5haXJlOiBzdGF0ZS5xdWVzdGlvbm5haXJlUmVzcG9uc2VzLFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2V0KCkuc3RhcnRBbmFseXNpcyhyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gVXRpbGl0eSBmdW5jdGlvbnNcbiAgICAgIGdldEFuYWx5c2lzQnlJZDogKGFuYWx5c2lzSWQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmFuYWx5c2lzSGlzdG9yeS5maW5kKGFuYWx5c2lzID0+IGFuYWx5c2lzLmFuYWx5c2lzX2lkID09PSBhbmFseXNpc0lkKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldFJlY2VudEFuYWx5c2VzOiAobGltaXQgPSAxMCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICByZXR1cm4gc3RhdGUuYW5hbHlzaXNIaXN0b3J5LnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIH0sXG5cbiAgICAgIGlzQW5hbHlzaXNDb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICByZXR1cm4gc3RhdGUuY3VycmVudEFuYWx5c2lzPy5zdGF0dXMgPT09ICdjb21wbGV0ZWQnO1xuICAgICAgfSxcblxuICAgICAgZ2V0QW5hbHlzaXNTdW1tYXJ5OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IGFuYWx5c2VzID0gc3RhdGUuYW5hbHlzaXNIaXN0b3J5O1xuICAgICAgICBjb25zdCBjb21wbGV0ZWQgPSBhbmFseXNlcy5maWx0ZXIoYSA9PiBhLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpO1xuICAgICAgICBjb25zdCBmYWlsZWQgPSBhbmFseXNlcy5maWx0ZXIoYSA9PiBhLnN0YXR1cyA9PT0gJ2ZhaWxlZCcpO1xuICAgICAgICBjb25zdCBzY29yZXMgPSBjb21wbGV0ZWRcbiAgICAgICAgICAubWFwKGEgPT4gYS5yZXN1bHRzPy5vdmVyYWxsX3Njb3JlKVxuICAgICAgICAgIC5maWx0ZXIoc2NvcmUgPT4gdHlwZW9mIHNjb3JlID09PSAnbnVtYmVyJykgYXMgbnVtYmVyW107XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvdGFsQW5hbHlzZXM6IGFuYWx5c2VzLmxlbmd0aCxcbiAgICAgICAgICBjb21wbGV0ZWRBbmFseXNlczogY29tcGxldGVkLmxlbmd0aCxcbiAgICAgICAgICBmYWlsZWRBbmFseXNlczogZmFpbGVkLmxlbmd0aCxcbiAgICAgICAgICBhdmVyYWdlU2NvcmU6IHNjb3Jlcy5sZW5ndGggPiAwID8gc2NvcmVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gc2NvcmVzLmxlbmd0aCA6IDAsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH0pLFxuICAgIHtcbiAgICAgIG5hbWU6ICdhbmFseXNpcy1zdG9yZScsXG4gICAgfVxuICApXG4pO1xuIl0sIm5hbWVzIjpbImNyZWF0ZSIsImRldnRvb2xzIiwiQW5hbHlzaXNTZXJ2aWNlIiwidXNlQW5hbHlzaXNTdG9yZSIsInNldCIsImdldCIsImN1cnJlbnRBbmFseXNpcyIsImN1cnJlbnRBbmFseXNpc0lkIiwiYW5hbHlzaXNIaXN0b3J5IiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJjdXJyZW50UGhhc2UiLCJwcm9ncmVzcyIsInJhd0Jpb21hcmtlcnMiLCJub3JtYWxpemVkQmlvbWFya2VycyIsInVubWFwcGVkQmlvbWFya2VycyIsInVzZXJQcm9maWxlIiwicXVlc3Rpb25uYWlyZVJlc3BvbnNlcyIsInF1ZXN0aW9ubmFpcmVDb21wbGV0ZWQiLCJldmVudFNvdXJjZSIsInNldEN1cnJlbnRBbmFseXNpcyIsImFuYWx5c2lzIiwic2V0Q3VycmVudEFuYWx5c2lzSWQiLCJhbmFseXNpc0lkIiwiYWRkVG9IaXN0b3J5Iiwic3RhdGUiLCJzbGljZSIsInNldExvYWRpbmciLCJsb2FkaW5nIiwic2V0RXJyb3IiLCJzZXRQaGFzZSIsInBoYXNlIiwic2V0UHJvZ3Jlc3MiLCJNYXRoIiwibWF4IiwibWluIiwic2V0UmF3QmlvbWFya2VycyIsImJpb21hcmtlcnMiLCJzZXROb3JtYWxpemVkQmlvbWFya2VycyIsInNldFVubWFwcGVkQmlvbWFya2VycyIsInVubWFwcGVkIiwic2V0VXNlclByb2ZpbGUiLCJwcm9maWxlIiwic2V0UXVlc3Rpb25uYWlyZVJlc3BvbnNlcyIsInJlc3BvbnNlcyIsInNldFF1ZXN0aW9ubmFpcmVDb21wbGV0ZWQiLCJjb21wbGV0ZWQiLCJzZXRSZXNwb25zZSIsImlkIiwidmFsdWUiLCJnZXRSZXNwb25zZSIsInJlc2V0UmVzcG9uc2VzIiwic3RhcnRBbmFseXNpcyIsInJlcXVlc3QiLCJjb25zb2xlIiwiZGVidWciLCJiaW9tYXJrZXJWYWxpZGF0aW9uIiwidmFsaWRhdGVCaW9tYXJrZXJEYXRhIiwidXNlclZhbGlkYXRpb24iLCJ2YWxpZGF0ZVVzZXJQcm9maWxlIiwidXNlciIsInZhbGlkIiwiZXJyb3JzIiwibWVzc2FnZSIsImpvaW4iLCJjb2RlIiwiZGV0YWlscyIsImJpb21hcmtlckVycm9ycyIsInVzZXJFcnJvcnMiLCJxdWVzdGlvbm5haXJlIiwicmVzcG9uc2UiLCJzdWNjZXNzIiwiRXJyb3IiLCJkYXRhIiwiYW5hbHlzaXNfaWQiLCJzdGF0dXMiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3Vic2NyaWJlVG9BbmFseXNpc0V2ZW50cyIsImV2ZW50IiwiSlNPTiIsInBhcnNlIiwibG9nIiwidXBkYXRlQW5hbHlzaXNQcm9ncmVzcyIsImNvbXBsZXRlQW5hbHlzaXMiLCJyZXN1bHRzIiwidHlwZSIsImZhaWxBbmFseXNpcyIsImdldEFuYWx5c2lzUmVzdWx0IiwiY29tcGxldGVkQW5hbHlzaXMiLCJjb21wbGV0ZWRfYXQiLCJjbHVzdGVycyIsImluc2lnaHRzIiwicmlza19hc3Nlc3NtZW50IiwicmVjb21tZW5kYXRpb25zIiwiZmFpbGVkQW5hbHlzaXMiLCJjbGVhckFuYWx5c2lzIiwiY2xvc2UiLCJyZXRyeUFuYWx5c2lzIiwiZ2V0QW5hbHlzaXNCeUlkIiwiZmluZCIsImdldFJlY2VudEFuYWx5c2VzIiwibGltaXQiLCJpc0FuYWx5c2lzQ29tcGxldGUiLCJnZXRBbmFseXNpc1N1bW1hcnkiLCJhbmFseXNlcyIsImZpbHRlciIsImEiLCJmYWlsZWQiLCJzY29yZXMiLCJtYXAiLCJvdmVyYWxsX3Njb3JlIiwic2NvcmUiLCJ0b3RhbEFuYWx5c2VzIiwibGVuZ3RoIiwiY29tcGxldGVkQW5hbHlzZXMiLCJmYWlsZWRBbmFseXNlcyIsImF2ZXJhZ2VTY29yZSIsInJlZHVjZSIsImIiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/state/analysisStore.ts\n"));

/***/ })

});